#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{amsmath,amssymb,dot2texi,tikz,hyperref,enumitem}
\usetikzlibrary{shapes,arrows}

\usepackage[T1]{fontenc}
\usepackage[sc]{mathpazo}
\usepackage{fullpage}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{url}
\usepackage{listings}

\lstdefinelanguage{sharpc}{language=[Sharp]C}

% "define" Scala
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{%
  \parbox{\textwidth}{\colorbox{black}{\parbox{\textwidth}{#1#2#3}}\vskip4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{frame=lrbt,xleftmargin=\fboxsep,xrightmargin=-\fboxsep}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic true
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

%Upper part of the page 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.50
\backslash
textwidth]{imperial_crest_colour.jpg}
\backslash

\backslash
[1cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
LARGE Imperial College London}
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Value dependent types for the CLI}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout

% Title 
\end_layout

\begin_layout Plain Layout


\backslash
HRule 
\backslash

\backslash
[0.4cm] 
\end_layout

\begin_layout Plain Layout

{ 
\backslash
huge 
\backslash
bfseries Type equality constraints}
\backslash

\backslash
[0.4cm]
\end_layout

\begin_layout Plain Layout


\backslash
HRule 
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout

% Author and supervisor 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Author:}
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Fraser 
\backslash
textsc{Waters}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
href{mailto:fraser.waters08@imperial.ac.uk}{fraser.waters08@imperial.ac.uk} 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushright} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Supervisor:} 
\backslash

\backslash
 Professor Sophia 
\backslash
textsc{Drossopoulou} 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushright} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Bottom of the page 
\end_layout

\begin_layout Plain Layout

{
\backslash
large 
\backslash
today}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Abstract
Type equality constraints would allow the CLI to better express generalized
 algebraic data types.
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Generalized algebraic data types
\end_layout

\begin_layout Standard
This report looks into how to add type equality constraints to the CLI.
 Type equality constraints for C# are described in 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

, we'll be using these ideas but for the CLI not C#.
 The basic idea is to extend generic constraints to allow equality constraints
 on generic types, section 3.1 (Equational constraints for C#) of 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 describes this extension.
 This would allow a generic type to be declared equal to another type, this
 would be checked statically at compile time.
 For example a list flatten method could check that the list was a list
 of lists by the addition of the 
\family typewriter
where T=List<U>
\family default
 clause.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

public abstract class List<T> {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	public abstract List<T> Append(List<T> list);
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() where T=List<U>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Nil<T> : List<T> {
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return new Nil<U>;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Cons<T> : List<T> {	
\end_layout

\begin_layout Plain Layout

	T head; List<T> tail;
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return this.head.Append(this.tail.Flatten());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calling 
\family typewriter
Flatten
\family default
 on a 
\family typewriter
List<T>
\family default
 would statically check that 
\family typewriter
T=List<U>
\family default
 where 
\family typewriter
U
\family default
 is any type.
 Thus in the method body of flatten we can assume that the type of 
\family typewriter
head
\family default
 is 
\family typewriter
List<U>
\family default
 which has an 
\family typewriter
Append
\family default
 method.
 While the paper suggests this as a C# extension generic constraints are
 currently encoded at the CLI level and so we could add this as a CLI extension,
 thus allowing this to be added to C# and other languages easily.
 
\end_layout

\begin_layout Section
Example
\end_layout

\begin_layout Standard
The following shows a minimal list example, in both C# and CIL.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Type equality constraints in extended C#
\end_layout

\end_inset

public abstract class List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public abstract List<T> Append(List<T> list);
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() where T=List<U>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Nil<T> : List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public override List<T> Append(List<T> list)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return list;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new Nil<U>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Cons<T> : List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	T Head;
\end_layout

\begin_layout Plain Layout

	List<T> Tail;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Cons(T head, List<T> tail) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Head = head;
\end_layout

\begin_layout Plain Layout

		Tail = tail;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override List<T> Append(List<T> list)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new Cons<T>(Head, Tail.Append(list));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return Head.Append(Tail.Flatten<U>());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Corresponding CIL
\end_layout

\end_inset

.class public abstract auto ansi beforefieldinit List<T>
\end_layout

\begin_layout Plain Layout

extends [mscorlib]System.Object 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	.method family hidebysig specialname rtspecialname instance void .ctor()
 
\end_layout

\begin_layout Plain Layout

		cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 8
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void [mscorlib]System.Object::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig newslot abstract virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{     }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig newslot abstract virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<= T List<!!0> U>() cil managed
\end_layout

\begin_layout Plain Layout

	{     }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.class public auto ansi beforefieldinit Nil<T>     
\end_layout

\begin_layout Plain Layout

	extends Test.List`1<!T> 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	.method public hidebysig specialname rtspecialname instance void .ctor()
 
\end_layout

\begin_layout Plain Layout

		cil managed     
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 8
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void Test.List`1<!T>::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 1
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<= T List<!!0> U>() cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 1
\end_layout

\begin_layout Plain Layout

		newobj instance void Test.Nil`1<!!U>::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.class public auto ansi beforefieldinit Cons<T>     
\end_layout

\begin_layout Plain Layout

extends Test.List`1<!T> 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	.method public hidebysig specialname rtspecialname instance void 
\end_layout

\begin_layout Plain Layout

		.ctor(!T head, class Test.List`1<!T> tail) cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 2        
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void Test.List`1<!T>::.ctor()
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		stfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldarg.2
\end_layout

\begin_layout Plain Layout

		stfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 3
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!T>::Append(class Test.List`1<!0>)
\end_layout

\begin_layout Plain Layout

		newobj instance void Test.Cons`1<!T>::.ctor(!0, class Test.List`1<!0>)
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .method public hidebysig virtual instance class
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<= T List<!!0> U>() cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 2
\end_layout

\begin_layout Plain Layout

		nop
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!T>::Flatten<!!U>()
\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!!U>::Append(class Test.List`1<!0>)
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .field private !T Head
\end_layout

\begin_layout Plain Layout

    .field private class Test.List`1<!T> Tail
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax here is purely to demonstrate the intuition of the feature.
 Exact syntax will be expanded on as we explore how this can be added to
 the CLI specification.
\end_layout

\begin_layout Chapter
Specification changes
\end_layout

\begin_layout Section
Generic constraints
\end_layout

\begin_layout Standard
Section 9.11 (Constraints on generic parameters)
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

 specifies generic constraints.
 A type parameter that has been constrained must be instantiated with an
 argument that is assignable to each of declared constraints, and that satisfies
 all special constraints.
\end_layout

\begin_layout Standard
The special constraints are, 
\family typewriter
+
\family default
, 
\family typewriter
-
\family default
, 
\family typewriter
class
\family default
, 
\family typewriter
valuetype
\family default
 and 
\family typewriter
.ctor
\family default
.
 
\family typewriter
class
\family default
 constrains the argument to be a reference type.
 
\family typewriter
valuetype
\family default
 constrains the argument to be a value type, except for any instance of
\family typewriter
 System.Nullable<T>
\family default
.
 
\family typewriter
.ctor
\family default
 constrains the argument to a type that has a public default constructor
 (implicitly this means all value types as value types always have a public
 default constructor).
 Finally 
\family typewriter
+
\family default
 and 
\family typewriter
-
\family default
 are used to denote the parameter is covariant or contravariant respectively.
\end_layout

\begin_layout Standard
While it might seem that this is a good place to add our extension type
 equality constraints are a constraint on the entire parameter list, not
 on each individual parameter.
 There's also the potential to add an equality constraint to a non-generic
 method.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc"
inline false
status open

\begin_layout Plain Layout

class Foo<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Bar(List<int> list) where T = int
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public void Baz(List<string> list) where T = string
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example 
\family typewriter
Bar
\family default
 can only be called if 
\family typewriter
Foo<T>
\family default
 was initialized with 
\family typewriter
int
\family default
, and 
\family typewriter
Baz
\family default
 only if it was initialized with 
\family typewriter
string
\family default
.
 A similar thing can be done with non-generic inner types.
 So we need to look to add this new syntax somewhere seperate to the generic
 parameter list.
 Preferably it would have similar syntax for both methods and types (as
 generic parameters look the same on a type declaration or method declaration).
 A type declaration currently follows the pattern 
\begin_inset Quotes eld
\end_inset


\family typewriter
.class ClassAttr* Id ['<' GenPars '>'] [extends TypeSpec [ implements TypeSpec]
 [',' TypeSpec]*]
\family default

\begin_inset Quotes erd
\end_inset

, while method declarations follow the pattern 
\begin_inset Quotes eld
\end_inset


\family typewriter
.method MethAttr* [CallConv] Type [marshal '(' [NativeType] ')'] MethodName
 ['<' GenPars '>'] '(' Parameters ')' ImplAttr*
\family default

\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Chapter
References
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "type_equality"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
