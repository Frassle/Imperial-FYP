#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{amsmath,amssymb,dot2texi,tikz,hyperref,enumitem}
\usetikzlibrary{shapes,arrows}

\usepackage[T1]{fontenc}
\usepackage[sc]{mathpazo}
\usepackage{fullpage}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{url}
\usepackage{listings}

\lstdefinelanguage{sharpc}{language=[Sharp]C}

% "define" Scala
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{%
  \parbox{\textwidth}{\colorbox{black}{\parbox{\textwidth}{#1#2#3}}\vskip4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{frame=lrbt,xleftmargin=\fboxsep,xrightmargin=-\fboxsep}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic true
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

%Upper part of the page 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.50
\backslash
textwidth]{imperial_crest_colour.jpg}
\backslash

\backslash
[1cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
LARGE Imperial College London}
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Value dependent types for the CLI}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout

% Title 
\end_layout

\begin_layout Plain Layout


\backslash
HRule 
\backslash

\backslash
[0.4cm] 
\end_layout

\begin_layout Plain Layout

{ 
\backslash
huge 
\backslash
bfseries Type equality constraints}
\backslash

\backslash
[0.4cm]
\end_layout

\begin_layout Plain Layout


\backslash
HRule 
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout

% Author and supervisor 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Author:}
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Fraser 
\backslash
textsc{Waters}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
href{mailto:fraser.waters08@imperial.ac.uk}{fraser.waters08@imperial.ac.uk} 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushright} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Supervisor:} 
\backslash

\backslash
 Professor Sophia 
\backslash
textsc{Drossopoulou} 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushright} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Bottom of the page 
\end_layout

\begin_layout Plain Layout

{
\backslash
large 
\backslash
today}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Abstract
Type equality constraints would allow the CLI to better express generalized
 algebraic data types.
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Generalized algebraic data types
\end_layout

\begin_layout Standard
Generalized algebraic data types (GADTs) are predominately a feature of
 functional languages.
 They are an extension to algebraic data types that reduce some constraints
 on data type constructors, in particular they allow pattern matching and
 recursion in a data constructor.
 The common example is a type for terms in a small language, without GADTs
 you cannot have the type checker check that the expression trees are correct.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=Haskell,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ADT
\end_layout

\end_inset

data Exp 
\end_layout

\begin_layout Plain Layout

	= Lit Int
\end_layout

\begin_layout Plain Layout

	| Plus Exp Exp 
\end_layout

\begin_layout Plain Layout

	| Equals Exp Exp
\end_layout

\begin_layout Plain Layout

	| Cond Exp Exp Exp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's clear that the first expression passed to 
\family typewriter
Cond
\family default
 must evaluate to a boolean result (from 
\family typewriter
Equals
\family default
), but the type system cannot express that.
 If we add GADTs to our language we can rewrite 
\family typewriter
Exp
\family default
 to the following.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
GADT
\end_layout

\end_inset

data Exp t where
\end_layout

\begin_layout Plain Layout

	Lit :: Int -> Exp Int
\end_layout

\begin_layout Plain Layout

	Plus :: Exp Int -> Exp Int -> Exp Int
\end_layout

\begin_layout Plain Layout

	Equals :: Exp Int -> Exp Int -> Exp Bool
\end_layout

\begin_layout Plain Layout

	Cond :: Exp Bool -> Exp a -> Exp a -> Exp a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This data type will only allow a boolean expression as the first argument
 to 
\family typewriter
Cond
\family default
.
 There are more examples that can be statically checked with GADTs such
 as lists that have their size as part of their type and statically typed
 printf functions.
\end_layout

\begin_layout Standard
The use of GADTs in object orientated languages is less common than in functiona
l languages (Haskell has supported GADTs for over 10 years) but 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 shows how GADT programs can be expressed in C# with some modifications
 to the language.
 The two modifications proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 are an extension of generic constraints and an extension of the switch
 statement.
 
\end_layout

\begin_layout Standard
The extension to generic constraints would allow equality constraints on
 generic types, section 3.1 (Equational constraints for C#) of 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 describes this extension.
 This would allow a generic type to be declared equal to another type, this
 would be checked statically at compile time.
 For example a list flatten method could check that the list was a list
 of lists by the addition of the 
\family typewriter
where T=List<U>
\family default
 clause.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

public abstract class List<T> {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	public abstract List<T> Append(List<T> list);
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() where T=List<U>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Nil<T> : List<T> {
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return new Nil<U>;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Cons<T> : List<T> {	
\end_layout

\begin_layout Plain Layout

	T head; List<T> tail;
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return this.head.Append(this.tail.Flatten());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calling 
\family typewriter
Flatten
\family default
 on a 
\family typewriter
List<T>
\family default
 would statically check that 
\family typewriter
T=List<U>
\family default
 where 
\family typewriter
U
\family default
 is any type.
 Thus in the method body of flatten we can assume that the type of 
\family typewriter
head
\family default
 is 
\family typewriter
List<U>
\family default
 which has an 
\family typewriter
Append
\family default
 method.
 While the paper suggests this as a C# extension generic constraints are
 currently encoded at the CLI level and so we could add this as a CLI extension,
 thus allowing this to be added to C# and other languages easily.
 
\end_layout

\begin_layout Standard
The second proposal is an extension to the switch statement to allow switching
 on types, binding type 
\family typewriter
variables
\family default
 in switch case clauses and matching multiple expressions.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

switch (e1, e2)
\end_layout

\begin_layout Plain Layout

	case (Lit x, Lit y):
\end_layout

\begin_layout Plain Layout

		return x.value == y.value;
\end_layout

\begin_layout Plain Layout

	case (Tuple<A,B> x, Tuple<C,D> y):
\end_layout

\begin_layout Plain Layout

		return Eq(x.fst, y.fst) && Eq(x.snd, y.snd);
\end_layout

\begin_layout Plain Layout

	default:
\end_layout

\begin_layout Plain Layout

		returna false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While switch statements are a language feature (at the CLI level they are
 encoded through a sequence of if statements) the authors point out that
 support at the CLI level for a match-and-bind primitive would be useful
 (see the end of section 3.4 in 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

).
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The first extension will be to add type equality constraints and a match
 and bind instruction to the CLI.
 To do this we will take the ideas from 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 and translate them to apply to the CLI.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Type equality constraints in extended C#
\end_layout

\end_inset

public abstract class List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public abstract List<T> Append(List<T> list);
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() where T=List<U>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Nil<T> : List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public override List<T> Append(List<T> list)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return list;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new Nil<U>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Cons<T> : List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	T Head;
\end_layout

\begin_layout Plain Layout

	List<T> Tail;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Cons(T head, List<T> tail) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Head = head;
\end_layout

\begin_layout Plain Layout

		Tail = tail;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override List<T> Append(List<T> list)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new Cons<T>(Head, Tail.Append(list));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return Head.Append(Tail.Flatten<U>());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Corresponding CIL
\end_layout

\end_inset

.class public abstract auto ansi beforefieldinit List<T>
\end_layout

\begin_layout Plain Layout

extends [mscorlib]System.Object 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	.method family hidebysig specialname rtspecialname instance void .ctor()
 
\end_layout

\begin_layout Plain Layout

		cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 8
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void [mscorlib]System.Object::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig newslot abstract virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{     }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig newslot abstract virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<= T List<!!0> U>() cil managed
\end_layout

\begin_layout Plain Layout

	{     }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.class public auto ansi beforefieldinit Nil<T>     
\end_layout

\begin_layout Plain Layout

	extends Test.List`1<!T> 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	.method public hidebysig specialname rtspecialname instance void .ctor()
 
\end_layout

\begin_layout Plain Layout

		cil managed     
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 8
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void Test.List`1<!T>::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 1
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<= T List<!!0> U>() cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 1
\end_layout

\begin_layout Plain Layout

		newobj instance void Test.Nil`1<!!U>::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.class public auto ansi beforefieldinit Cons<T>     
\end_layout

\begin_layout Plain Layout

extends Test.List`1<!T> 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	.method public hidebysig specialname rtspecialname instance void 
\end_layout

\begin_layout Plain Layout

		.ctor(!T head, class Test.List`1<!T> tail) cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 2        
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void Test.List`1<!T>::.ctor()
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		stfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldarg.2
\end_layout

\begin_layout Plain Layout

		stfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 3
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!T>::Append(class Test.List`1<!0>)
\end_layout

\begin_layout Plain Layout

		newobj instance void Test.Cons`1<!T>::.ctor(!0, class Test.List`1<!0>)
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .method public hidebysig virtual instance class
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<= T List<!!0> U>() cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 2
\end_layout

\begin_layout Plain Layout

		nop
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!T>::Flatten<!!U>()
\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!!U>::Append(class Test.List`1<!0>)
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .field private !T Head
\end_layout

\begin_layout Plain Layout

    .field private class Test.List`1<!T> Tail
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
References
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "report"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
