\chapter{Type equality constraints}

\section{Generalized algebraic data types}

The first extension will be to add type equality constraints to the CLI. 
Type equality constraints for C\# are described in \cite{gadts}, we will 
be using these ideas but for the CLI not C\#. The basic idea is to extend 
generic constraints to allow equality constraints on generic types, section 
3.1 (Equational constraints for C\#) of \cite{gadts} describes this extension. 
This would allow a generic type to be declared equal to another type, this 
would be checked statically at compile time. For example a list flatten method
could check that the list was a list of lists by the addition of the 
\texttt{where T=List<U>} clause.

\begin{lstlisting}[keywordstyle={\color{blue}},language=sharpc,tabsize=4]
public abstract class List<T> {
	...
	public abstract List<T> Append(List<T> list);
	public abstract List<U> Flatten<U>() where T=List<U>;
}

public class Nil<T> : List<T> {
	public override List<U> Flatten<U>() {
		return new Nil<U>;
	}
}

public class Cons<T> : List<T> {	
	T head; List<T> tail;
	public override List<U> Flatten<U>() {
		return this.head.Append(this.tail.Flatten());
	}
}
\end{lstlisting}

Calling \texttt{Flatten} on a \texttt{List<T>} would statically check
that \texttt{T=List<U>} where \texttt{U} is any type. Thus in the
method body of flatten we can assume that the type of \texttt{head}
is \texttt{List<U>} which has an \texttt{Append} method. While the
paper suggests this as a C\# extension generic constraints are currently
encoded at the CLI level and so we could add this as a CLI extension,
thus allowing this to be added to C\# and other languages easily. 

\subsection{Example}

The following shows a minimal list example, in both C\# and CIL.


\begin{lstlisting}[caption={Type equality constraints in extended C\#\protect \\
Extension of listing \ref{lis:csharp gadt}},escapechar={~},keywordstyle={\color{blue}},language=sharpc]
public abstract class List<T>
{
	public abstract List<T> Append(List<T> list);
	public abstract List<U> Flatten<U>() ~\colorbox{yellow}{where T=List<U>;}~
}

public class Nil<T> : List<T>
{
	public override List<T> Append(List<T> list)
	{
		return list;
	}
	public abstract List<U> Flatten<U>() // type constraints are inherited
	{
		return new Nil<U>();
	}
}

public class Cons<T> : List<T>
{
	T Head;
	List<T> Tail;

	public Cons(T head, List<T> tail) 
	{
		Head = head;
		Tail = tail;
	}

	public override List<T> Append(List<T> list)
	{
		return new Cons<T>(Head, Tail.Append(list));
	}

	public override List<U> Flatten<U>() // type constraints are inherited
	{
		return Head.Append(Tail.Flatten<U>()); // invalid in standard C#
	}
}
\end{lstlisting}

\begin{lstlisting}[caption={Corresponding CIL},escapechar={~},language=cil]
.class public abstract auto ansi beforefieldinit List<T>
extends [mscorlib]System.Object 
{
	.method family hidebysig specialname rtspecialname instance void .ctor() 
		cil managed
	{
		.maxstack 8
		ldarg.0
		call instance void [mscorlib]System.Object::.ctor()
		ret
	}

	.method public hidebysig newslot abstract virtual instance class 
		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
	{     }

	.method public hidebysig newslot abstract virtual instance class 
		Test.List`1<!!U> Flatten<~\colorbox{yellow}{= T List<!!0>}~ U>() cil managed
	{     }
}

.class public auto ansi beforefieldinit Nil<T>     
	extends Test.List`1<!T> 
{     
	.method public hidebysig specialname rtspecialname instance void .ctor() 
		cil managed     
	{
		.maxstack 8
		ldarg.0
		call instance void Test.List`1<!T>::.ctor()
		ret
	}

	.method public hidebysig virtual instance class 
		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
	{
		.maxstack 1
		ldarg.1
		ret
	}

	.method public hidebysig virtual instance class 
		Test.List`1<!!U> Flatten<~\colorbox{yellow}{= t list<!!0>}~ U>() cil managed
	{
		.maxstack 1
		newobj instance void Test.Nil`1<!!U>::.ctor()
		ret
	}
}

.class public auto ansi beforefieldinit Cons<T>     
extends Test.List`1<!T> 
{
	.method public hidebysig specialname rtspecialname instance void 
		.ctor(!T head, class Test.List`1<!T> tail) cil managed     
	{         
		.maxstack 2        
		ldarg.0
		call instance void Test.List`1<!T>::.ctor()
		ldarg.0
		ldarg.1
		stfld !0 Test.Cons`1<!T>::Head
		ldarg.0
		ldarg.2
		stfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
		ret
	}
	
	.method public hidebysig virtual instance class 
		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
	{         
		.maxstack 3
		ldarg.0
		ldfld !0 Test.Cons`1<!T>::Head
		ldarg.0
		ldfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
		ldarg.1
		callvirt instance class Test.List`1<!0> 
			Test.List`1<!T>::Append(class Test.List`1<!0>)
		newobj instance void Test.Cons`1<!T>::.ctor(!0, class Test.List`1<!0>)
		ret
	}

    .method public hidebysig virtual instance class
		Test.List`1<!!U> Flatten<~\colorbox{yellow}{= T List<!!0>}~ U>() cil managed     
	{         
		.maxstack 2
		nop
		ldarg.0
		ldfld !0 Test.Cons`1<!T>::Head
		ldarg.0
		ldfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
		callvirt instance class Test.List`1<!!0> 
			Test.List`1<!T>::Flatten<!!U>()

		// the following callvirt would not verify in the standard CLI

		callvirt instance class Test.List`1<!0> 
			Test.List`1<!!U>::Append(class Test.List`1<!0>) 
		ret
	}

    .field private !T Head
    .field private class Test.List`1<!T> Tail
}
\end{lstlisting}

The syntax here is purely to demonstrate the intuition of the feature.
Exact syntax will be expanded on as we explore how this can be added
to the CLI specification.

\section{Specification changes}

\subsection{Generic constraints}

Section II.9.11 (Constraints on generic parameters)\cite{ecma-335} specifies
generic constraints. A type parameter that has been constrained must
be instantiated with an argument that is assignable to each of declared
constraints, and that satisfies all special constraints.

The special constraints are, \texttt{+}, \texttt{-}, \texttt{class},
\texttt{valuetype} and \texttt{.ctor}. \texttt{class} constrains the
argument to be a reference type. \texttt{valuetype} constrains the
argument to be a value type, except for any instance of\texttt{ System.Nullable<T>}.
\texttt{.ctor} constrains the argument to a type that has a public
default constructor (implicitly this means all value types as value
types always have a public default constructor). Finally \texttt{+}
and \texttt{-} are used to denote the parameter is covariant or contravariant
respectively.

While it might seem that this is a good place to add our extension
type equality constraints are a constraint on the entire parameter
list, not on each individual parameter. There's also the potential
to add an equality constraint to a non-generic method.

\begin{lstlisting}[keywordstyle={\color{blue}},language=sharpc]
class Foo<T>
{
	public void Bar(List<int> list) where T = int
	{
		...
	}
	
	public void Baz(List<string> list) where T = string
	{
		...
	}
}
\end{lstlisting}

In this example \texttt{Bar} can only be called if \texttt{Foo<T>}
was initialized with \texttt{int}, and \texttt{Baz} only if it was
initialized with \texttt{string}. A similar thing can be done with
non-generic inner types. So we need to look to add this new syntax
somewhere separate to the generic parameter list. Preferably it would
have similar syntax for both methods and types (as generic parameters
look the same on a type declaration or method declaration). A type
declaration currently follows the pattern ``\texttt{.class ClassAttr{*}
Id {[}'<' GenPars '>'{]} {[}extends TypeSpec {[} implements TypeSpec{]}
{[}',' TypeSpec{]}{*}{]}}'', while method declarations follow the
pattern ``\texttt{.method MethAttr{*} {[}CallConv{]} Type {[}marshal
'(' {[}NativeType{]} ')'{]} MethodName {[}'<' GenPars '>'{]} '(' Parameters
')' ImplAttr{*}}''.

Adding a new clause ``\texttt{where {[}Type '=' Type{[}',' Type '=' Type{]}{*}{]}}
to method declarations after the parameter list gives us a list of Types that must 
be equal to other types. It's not strictly necessary to have this clause on type 
declarations as for top level types it makes very little sense and for inner types 
it can be emulated be adding the clause to each method.

\subsection{Assignment compatibility}

Assignment compatibility is defined in section I.8.7 of \cite{ecma-335}, further to this 
verification assignment compatibility is defined in III.1.8.1.2.3. Verification assignment 
compatibility is mostly defined in terms of general assignment compatibility from I.8.7.3.

Verification assignment compatibility is used be the verifier for determining if method calls, field 
references and loads and stores are valid for a given type and signature. If verification assignment compatibility 
is extended to understand type equality constraints then operations that were unverifiable but type correct can now
be checked as verifiable as well.

Adding another rule to \emph{verifier-assignable-to} to use the rules for equality constraints is all that is needed
to enhance this part of the system.

\textbullet{} T is \emph{equal-to} U.

\subsubsection{\emph{equal-to}}

\emph{equal-to} is used to determine if two type names refer to the same actual type.
It uses the both the global typing environment $\Gamma$ and the
equality constraints on the current method $\epsilon$ which defines equal types.

\begin{prooftree}
\AxiomC{$T=U \in \epsilon$}
\LeftLabel{eq-hyp}
\UnaryInfC{$\Gamma,\epsilon \vdash T=U$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$T=U \in \epsilon$}
\AxiomC{$\Gamma \vdash C<T> \,\mathit{ok}$}
\LeftLabel{eq-con}
\BinaryInfC{$\Gamma,\epsilon \vdash C<T>=C<U>$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma,\epsilon \vdash C<T>=C<U>$}
\LeftLabel{eq-decon}
\UnaryInfC{$\Gamma,\epsilon \vdash T=U$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash T \,\mathit{ok}$}
\LeftLabel{eq-refl}
\UnaryInfC{$\Gamma,\epsilon \vdash T=T$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$U=T \in \epsilon$}
\LeftLabel{eq-sym}
\UnaryInfC{$\Gamma,\epsilon \vdash T=U$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma,\epsilon \vdash T=U$}
\AxiomC{$\Gamma,\epsilon \vdash U=V$}
\LeftLabel{eq-sym}
\BinaryInfC{$\Gamma,\epsilon \vdash T=V$}
\end{prooftree}

\subsection{Method calls}

Any method calls must be checked that any equality constraints on the method being called 
can be satisfied by the current context. This is done by checking that for each constraint listed on the 
method ($T=U$) T and U are \emph{equal-to} in the current context after applying substitution for generic parameters.

\begin{prooftree}
\AxiomC{$\Gamma \vdash m : <\bar{U}> \,\mathit{where}\, \epsilon'$}
\AxiomC{$\forall e \in (\epsilon'[\bar{T}/\bar{U}]).\Gamma, \epsilon \vdash e$}
\LeftLabel{call}
\BinaryInfC{$\Gamma,\epsilon \vdash m<\bar{T}>$}
\end{prooftree}

This is an addition to the verifiability rules for the call, calli and callvirt instructions.

\subsection{Metadata tables}

Metadata tables are specified in section 22 (Metadata logical format:
tables). We're mostly interested in section 22.21 (GenericParamConstraint),
which explains how generic constraints are stored in the assembly. 
\begin{quotation}
The GenericParamConstraint table has the following columns:

\textbullet{} Owner (an index into the GenericParam table, specifying
to which generic parameter this row refers) 

\textbullet{} Constraint (an index into the TypeDef, TypeRef, or TypeSpec
tables, specifying from which class this generic parameter is constrained
to derive; or which interface this generic parameter is constrained
to implement; more precisely, a TypeDefOrRef (§24.2.6) coded index) 

The GenericParamConstraint table records the constraints for each
generic parameter. Each generic parameter can be constrained to derive
from zero or one class. Each generic parameter can be constrained
to implement zero or more interfaces. 

Conceptually, each row in the GenericParamConstraint table is owned
by a row in the GenericParam table. 

All rows in the GenericParamConstraint table for a given Owner shall
refer to distinct constraints.
\end{quotation}
We need a similar table for our equality constraints. It will need
an owner (a type or method) and then two types that are constrained
to be equal within the owner. Another column that isn't necessary
but could be useful is a flags field describing the relationship between
the two types, currently this would always be set to equal, however
the system could be extended at a later date to allow less than and
greater than relationships as well.

So the TypeRelationshipConstraint table has the following columns:
\begin{itemize}
\item Owner (an index into the MethodDef table, specifying the
Method to which this constraint applies)
\item Flags (a 1-byte flag bitmask currently always set to 0. To be used
for extensions)
\item ConstraintA (an index into the TypeDef, TypeRef, or TypeSpec tables,
specifying the first type; more precisely, a TypeDefOrRef (§24.2.6)
coded index)
\item ConstraintB (an index into the TypeDef, TypeRef, or TypeSpec tables,
specifying the second type; more precisely, a TypeDefOrRef (§24.2.6)
coded index)
\end{itemize}

\section{Implementation changes}

\subsection{Runtime}

The runtime needs to be changed to load and understand equality constraint
metadata, these changes will be focused in mono/metadata/metadata.h/c and
mono/metadata/reflection.h/c.  The TypeRelationshipConstraint table is very
similar to the GenericParamConstraint table, the current code for
GenericParamConstraint can guide the new code for TypeRelationshipConstraint.

Verification is done in verify.c. Additions need to be made to verify that type
relationship constraints are met when calling methods and to extend assignment
compatibility to use those type relationship constraints.  This requires
additions to \texttt{mono\_method\_verify} to check constraints on
\texttt{call}, \texttt{calli} and \texttt{callvirt} instructions, this can
probably be done in \texttt{do\_invoke\_method}.  It also requires additions to
\texttt{verify\_stack\_type\_compatibility\_full} to check the new assignment
compatibility rules.

\subsection{corlib}

The core library needs to be changed to support type equality. Specifically the
reflection library defined in mcs/class/corlib/System.Reflection\[.Emit\]. This
API is predominately implement via internal calls that are then defined in
mono/metadata/icall-def.h.

\subsection{Cecil and IKVM}

Mono.Cecil and IKVM are well known libraries for working with CIL code. They
are generally considered better than the core library System.Reflection and
System.Reflection.Emit. Any extensions of the system would be well served by
extending these libraries to understand the extension as well.

\section{Testing}

As part of any implementation a number of test cases should be developed to
show that the system works. These tests need to show that there is no CLI code
that does not run in the new system (backwards compatibility) and that the new
system is correct.

Normally these tests would be written in CIL assembly, however writing tests in
CIL assembly would be time consuming and error prone. Instead test writing
should be assisted by an assembly rewriter. The rewriter will look for calls to
special methods and attributes in a CLI assembly and rewrite the bytecode and
metadata to use features in the extended system.  Assembly rewriting will be
done using the CLI metadata reflection, writing and rewriting via
\texttt{System.Reflection} or another metadata editor such as
\textt{Mono.Cecil}.  Any implementation will extend these objects to support
the new metadata constructs.  With this we can mark up standard C\# or F\# code
with special methods and attributes and rewrite the resulting assemblies to
include the new metadata.

This system of testing has a number of advantages. Firstly it allows us to
write our tests in a high level language such as C\# instead of low level CIL.
The main benefit of writing in a high level language should be clear, it's much
easier. However we also get another less obvious benefit, that we are able to
test both imperative (C\#) and functional (F\#) code. This should mean coverage
over most aspects of the CLI.

Secondly we can run the tests on the standard CLI, this gives us something to
test against. Running in the standard CLI is not equivalent to running the
rewritten program in the new CLI (which we will call CLI+), but does allow some
deductions to be made.

For type equality there are two methods we need to define. \texttt{U Cast<T,
U>(T obj)} that checks \texttt{T} and \texttt{U} are equal at runtime and casts
\texttt{obj} to type \texttt{U} if they are; and \texttt{void EqualTypes<T,
U>()} that will check that T and U are equal types at runtime. Both these
methods will throw an exception \texttt{TypeEqualityException} if \texttt{T}
and \texttt{U} are not equal.

The rewriter will search an assembly for uses of \texttt{Cast<T, U>} and
\texttt{EqualTypes<T,U>}. Any use of \texttt{EqualTypes<T,U>} will be removed
and the method metadata rewritten to include the new type equality tags. Any
use of \texttt{Cast<T, U>} will also rewrite the metadata to include the new
type equality tags and will also remove the call to \texttt{Cast}.

\begin{lstlisting}[caption={Cast},keywordstyle={\color{blue}},language=sharpc]
public static class TypeEquality
{
	public static U Cast<T, U>(T obj)
	{
		if(typeof(T) == typeof(U))
		{
			return (U)(Object)obj;
		}
		else
		{
			throw new TypeEqualityException();
		}
	}
	public static void EqualTypes<T, U>()
	{
		if(typeof(T) != typeof(U))
		{
			throw new TypeEqualityException();
		}
	}
}
\end{lstlisting}

A program $P$ is the source code in a CLI language, such as C\#. It may or may
not make use of \texttt{TypeEquality.Cast} and
\texttt{TypeEquality.EqualTypes}. It can be compiled by a compiler $C$ to give
a CIL assembly, this assembly can be run on a runtime to give a value. The two
runtimes are $CLI$ and $CLI+$, values are either some value $v$ representing
the overall act of computation done by the program or an exception thrown by
the program, the only exceptions we care about are $TypeEqualityException$, or
$VerificationException$.  Finally a CIL assembly can be rewritten by the
rewriter $R$ to produce a CIL+ assembly.

If $R$ and CLI+ are correct then the following statements should hold:
\begin{lemma}
$C(P) \underset{CLI}{\rightarrow} TypeEqualityException \implies R(C(P))
\underset{CLI+}{\rightarrow} VerificationException$
\end{lemma}
\begin{lemma}
$R(C(P)) \underset{CLI+}{\not\rightarrow} VerificationException \implies
C(P) \underset{CLI}{\not\rightarrow} TypeEqualityException$
\end{lemma}
\begin{lemma}
$C(P) \underset{CLI}{\rightarrow} v \wedge R(C(P))
\underset{CLI+}{\not\rightarrow} VerificationException \implies R(C(P))
\underset{CLI+}{\rightarrow} v$
\end{lemma}
\begin{lemma}
$C(P) \underset{CLI}{\rightarrow} v \iff C(P) \underset{CLI+}{\rightarrow} v$
\end{lemma}

Lemma 1 states that if a program throws a \texttt{TypeEqualityException} in
the standard CLI then it will throw a \texttt{VerificationException} in the new
CLI. If CLI+ doesn't throw a \texttt{VerificationException} then we know
something is wrong with either the rewriter or the new runtime. For the sake of
these tests we will assume that the rewriter is correct. This property does not
hold in reverse ($R(C(P)) \underset{CLI+}{\rightarrow} VerificationException
\implies C(P) \underset{CLI}{\rightarrow} TypeEqualityException$) as the call
to \texttt{Cast<T, U>} or \texttt{EqualTypes<T, U>} might not be hit be every
control flow path.

Lemma 2 states that if the rewritten program runs in CLI+ and does not throw a
\texttt{VerificationException} then running the code in the CLI will not throw
a \texttt{TypeEqualityException}. If a \texttt{TypeEqualityException} is thrown
then something is wrong with the new runtime.

Lemma 3 states that if the program computes a value $v$ in the standard CLI
and verifies correctly in the new CLI then the new CLI should compute the same
value $v$.

Lemma 4 states that if the same CLI assembly (no rewriting) is run on both
runtimes they should compute the same value. While this is similar to lemma 3
it's difference is the lack of any assembly rewriting. 

All this together means that we can do some verification of our new system
against the old system. If a program ran correctly in the old system it should
also run correctly in the new system (lemma 4). If a program has correct equality type
constraints then it should run in the old system (and by the lemma 4 also
run in the new system) and when rewritten it should run in the new system
(lemma 3). If a program throws a \texttt{TypeEqualityException} then it should
throw a \texttt{VerificationException} when rewritten and run in the new
system.

\section{Testing without a full implementation}

While the above test plan is appropriate for checking an implementation is correct
we do not have a real implementation. However we still wish to show that the system
could work and is statically checkable. To do this we will be using a similar system to 
above. We can continue to write tests as described above, however instead of using 
an assembly rewriter to transform them into an extended CIL format we simply perform
the checks that the extended verifier would perform. Thus for every method call we 
check to see if it calls \texttt{EqualTypes} and if so check that we can satisfy 
those constraints, and for every call to \texttt{Cast} we check that the two types
are indeed equal either directly or via equality constraints.
