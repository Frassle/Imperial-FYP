#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{amsmath,amssymb,dot2texi,tikz,hyperref,enumitem}
\usetikzlibrary{shapes,arrows}

\usepackage[T1]{fontenc}
\usepackage[sc]{mathpazo}
\usepackage{fullpage}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{url}
\usepackage{listings}

% "define" Scala
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic true
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

%Upper part of the page 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.50
\backslash
textwidth]{imperial_crest_colour.jpg}
\backslash

\backslash
[1cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
LARGE Imperial College London}
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Interim Report}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout

% Title 
\end_layout

\begin_layout Plain Layout


\backslash
HRule 
\backslash

\backslash
[0.4cm] 
\end_layout

\begin_layout Plain Layout

{ 
\backslash
huge 
\backslash
bfseries Value dependent types for the CLI}
\backslash

\backslash
[0.4cm]
\end_layout

\begin_layout Plain Layout


\backslash
HRule 
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout

% Author and supervisor 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Author:}
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Fraser 
\backslash
textsc{Waters}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
href{mailto:fraser.waters08@imperial.ac.uk}{fraser.waters08@imperial.ac.uk} 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushright} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Supervisor:} 
\backslash

\backslash
 Professor Sophia 
\backslash
textsc{Drossopoulou} 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushright} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Bottom of the page 
\end_layout

\begin_layout Plain Layout

{
\backslash
large 
\backslash
today}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Abstract
Value dependent types are a powerful extension to type systems allowing
 types to be parametrized by terms.
 This project looks into how value dependent types could be introduced to
 the CLI, the underlying virtual machine specification for C#, Visual Basic,
 F# and many other languages, to allow more solutions to be succinctly expressed
 at the CLI level and exposed to these languages.
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Value dependent types
\end_layout

\begin_layout Standard
Dependent types allow static typing of expression based on values rather
 than just other types.
 There are some functional languages such as Agda
\begin_inset CommandInset citation
LatexCommand cite
key "agda"

\end_inset

, Coq
\begin_inset CommandInset citation
LatexCommand cite
key "coq"

\end_inset

, Idris
\begin_inset CommandInset citation
LatexCommand cite
key "idris"

\end_inset

 and Cayanne
\begin_inset CommandInset citation
LatexCommand cite
key "cayenne"

\end_inset

 that support dependent types, but in object oriented languages dependent
 types are not so common.
 While fully general value dependent types are rare, some weaker versions,
 including path dependent types (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Path-dependent-types"

\end_inset

) and virtual types (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Virtual-types"

\end_inset

), are used in some mainstream languages.
 Notably Scala
\begin_inset CommandInset citation
LatexCommand cite
key "scala"

\end_inset

 supports both path dependence and virtual types, F#
\begin_inset CommandInset citation
LatexCommand cite
key "fsharp"

\end_inset

 supports units of measure (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Fsharp-units"

\end_inset

) allowing numbers to be typed based on a unit value, and C++ has templates
 (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Cpp-templates"

\end_inset

) that can be parametrized on values.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
One of the main motivations for looking into value dependence is for work
 in graphics and physics applications where most vectors and matrices in
 the problem domain are small (3 or 4 elements, but no reason this couldn't
 scale to many more for other applications).
 Using types such as Vector3, Vector4, Matrix3x4 which are 3 and 4 element
 float vectors and a 3 by 4 float matrix respectively, make writing code
 much easier than working with multiple float variables.
 Currently there is no nice way to represent all the different sizes for
 types like this in C# (or any other CLI language).
 Consequently it lead me to the creation of a numeric type generator, a
 separate program that outputs the source code for a pre defined set of
 configurations (currently Vector2 to Vector8 and Matrix2x2 up to Matrix4x4).
 While the use of these types is mostly acceptable extending them is difficult.
 As shown below using the generator requires writing the code in literal
 strings, these literals can not be checked at compile time for obvious
 mistakes and the IDE does not offer auto completion when writing them,
 the generator has to be run then the emitted code must be compiled to see
 any problems.
 The following shows a section of code used to generate all the required
 dot product functions currently, 
\family typewriter
Components
\family default
 is a list of component indices 0, 1, 2 etc.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (!Type.IsCLSCompliant) { WriteLine("[CLSCompliant(false)]"); }       
      
\end_layout

\begin_layout Plain Layout

WriteLine("public static float Dot({0} left, {0} right)", Name);       
      
\end_layout

\begin_layout Plain Layout

WriteLine("{");             
\end_layout

\begin_layout Plain Layout

Indent();
\end_layout

\begin_layout Plain Layout

var dotproduct = string.Join("+",
\end_layout

\begin_layout Plain Layout

	Components.Select(component => string.Format("left[{0}]*right[{0}]", component)))
;
\end_layout

\begin_layout Plain Layout

WriteLine("return {0};", dotproduct);
\end_layout

\begin_layout Plain Layout

Dedent();
\end_layout

\begin_layout Plain Layout

WriteLine("}");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With value dependence we could write the code directly to be compiled, skipping
 the generator step, and allowing the use of auto complete and faster iteration
 times.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static float Dot<int n>(Vector<n> left, Vector<n> right)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	float dot = 0;
\end_layout

\begin_layout Plain Layout

	for(int i=0; i<n; ++i)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		dot += left[i]*right[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return dot;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The usage of these types would remain nearly the same, the following shows
 how they look at the moment compared to what they might look like with
 value dependence.
\end_layout

\begin_layout Standard
Current method:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

var a = new Vector3(1, 1, 1);
\end_layout

\begin_layout Plain Layout

var b = new Vector3(2, 2, 2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var ab = b - a;
\end_layout

\begin_layout Plain Layout

var dot = Vector.Dot(ab, a);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Proposal:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = new Vector<3>(1, 1, 1);
\end_layout

\begin_layout Plain Layout

var b = new Vector<3>(2, 2, 2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var ab = b - a;
\end_layout

\begin_layout Plain Layout

var dot = Vector.Dot(ab, a);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see there isn't a big difference.
 Users get more benefit with the latter as they can write dependent functions
 that work for any vector size, as opposed to having to use multiple functions
 for different sizes.
\end_layout

\begin_layout Subsection
Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Performance"

\end_inset


\end_layout

\begin_layout Standard
There are ways to avoid the generator step now, however they do not have
 acceptable performance and layout properties to be used.
 
\end_layout

\begin_layout Standard
The simlest way is to define Vector as dynamicly sized (like arrays) this
 loses all static type safety but does mean functions would only have to
 be written once, saving us the effort of creating and maintaining the generator
 but a cost.
 Vector is no longer purely a value type as it will have a referance field
 in it, this changes the semantics from the current vector types (due to
 no user defined copy constructors or assingment operators in the CLI) and
 also makes them more expensive as they are now tracked by the garbage collector.
 It also makes inter operating with native APIs such as OpenGL harder as
 the Vectors will have to be marshaled to correctly copy the ellements of
 their internal array to the native API, the current vector types can just
 be pinned and pointer copied.
\end_layout

\begin_layout Standard
Another way is to define an interface 
\family typewriter
Vector
\family default
 that defines the indexing operator and length property, and then write
 functions using this interface.
 However we still need to create concrete types for each vector size which
 requires the generator.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

interface Vector
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int Length { get; }
\end_layout

\begin_layout Plain Layout

	float this[int index] { get; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public static float Dot<T>(T a, T b) where T : Vector
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	float dot = 0;
\end_layout

\begin_layout Plain Layout

	for(int i=0; i<a.Length; ++i)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		dot += a[i]*b[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return dot;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The issue with this interface approach (and this give some suggestion as
 to how we would want to implement dependent types) is that the loop cannot
 be unrolled.
 For high performance code that theses small vector types are supposed to
 be used for that's an unacceptable trade off, especially as we still have
 to maintain the generator anyway.
 With dependent types we could have better performance characteristics and
 with the preferred flat data layout.
 
\end_layout

\begin_layout Standard
While these vector types are the main motivator for value dependence there
 are more uses for value dependent types, we explore these in the background
 section.
\end_layout

\begin_layout Section
The CLI
\begin_inset Foot
status open

\begin_layout Plain Layout
Common Language Infrastructure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The CLI is a specification for a virtual execution environment, that is
 implemented by Microsoft’s CLR
\begin_inset Foot
status open

\begin_layout Plain Layout
Common Language Runtime
\end_layout

\end_inset

 (often confused with the .NET branding) and the open source Mono project.
 It is targeted by VB, C#, F#, IronPython and other languages.
 It retains a high level of type information, more so than the Java Virtual
 Machine (which for example has no concept of generic types despite Java
 supporting them
\begin_inset CommandInset citation
LatexCommand cite
key "jvm-erasure"

\end_inset

).
\end_layout

\begin_layout Standard
As a C# and F# programmer the CLI is a more attractive specification to
 work with.
 The ability to retain high level type information allows easy interoperability
 between separate CLI modules, even with modules compiled using different
 languages.
\end_layout

\begin_layout Standard
However this interoperability starts to fall apart when languages add typing
 extensions that aren't supported by the CLI.
 Units of measure in F#, for example, are erased at compile time; therefore
 other modules which consume an F# module where units of measure were used
 cannot see, and be type-checked according to, the units.
 This loss of typing information is not ideal, as it reduces interoperability,
 and so prompts us to consider adding value dependence as a CLI feature
 and not just an extension to a current CLI language such as C# or F#.
 If units could be written in terms of dependent types then we can 
\emph on
fix
\emph default
 them, else at least our extension will not suffer the same problem of interoper
ability.
 
\end_layout

\begin_layout Standard
Moreover any new features added to the CLI should be backwards compatible
 and efficient, we need to keep in mind the size of the new types and their
 instances, the size of the byte code and the speed to process it and the
 speed and size of the JITed code.
\end_layout

\begin_layout Section
Project
\end_layout

\begin_layout Standard
This project will investigate value dependent types in the CLI.
 It will be split into 3 parts.
 
\end_layout

\begin_layout Enumerate
To investigate the use and benefits of value dependent typing.
\end_layout

\begin_layout Enumerate
To show how value dependent types could be added to the CLI, preferably
 in a clean and backwards compatible way.
\end_layout

\begin_layout Enumerate
If part 2 is successful to implement value dependent typing in Mono.
 
\end_layout

\begin_layout Enumerate
If part 2 is unsuccessful then an through explanation of why it can't be
 done should be written.
\end_layout

\begin_layout Standard
The rest of this report looks more in depth at the CLI and then covers various
 type system enhancements related to value dependence and value dependence
 itself.
 It finishes with an plan for the rest of the project and it's evaluation.
\end_layout

\begin_layout Chapter
Background
\end_layout

\begin_layout Section
The CLI
\end_layout

\begin_layout Subsection
Common intermediate language
\end_layout

\begin_layout Standard
The CLI runs Common Intermediate Language (CIL) byte code.
 CIL is a type rich, stack based assembly language.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.assembly Hello {} 
\end_layout

\begin_layout Plain Layout

.assembly extern mscorlib {} 
\end_layout

\begin_layout Plain Layout

.method static void Main() 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	.entrypoint     
\end_layout

\begin_layout Plain Layout

	.maxstack 1     
\end_layout

\begin_layout Plain Layout

	ldstr "Hello, world!"     
\end_layout

\begin_layout Plain Layout

	call void [mscorlib]System.Console::WriteLine(string)     
\end_layout

\begin_layout Plain Layout

	ret 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
CIL supports many features not common the low level assembly code.
 As well as basic operations such as add, jump, load, store, operations
 such as field access, method call, object creation, casting etc all have
 CIL instructions.
\end_layout

\begin_layout Standard
While CIL is targeted by a variety of languages Visual Basic and C# match
 it's semantics most closely.
 We will use C# code instead of raw CIL when possible in examples.
 Some C# features are uncommon in other languages so we we'll briefly go
 over them.
\end_layout

\begin_layout Subsection
Value and Reference types
\end_layout

\begin_layout Standard
The CLI differentiates between value types (structs) and reference types
 (classes).
 Value types are allocated inline, either on the stack or as part of a containin
g types allocation.
 Reference types are allocated on the heap and referred to by a pointer
 (called a reference).
\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Standard
As pointed out above the CIL has instructions for field access but it also
 supports properties.
 In the CIL code these look similar to method calls but in C# they look
 like field access.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Square {
\end_layout

\begin_layout Plain Layout

	public int Length;
\end_layout

\begin_layout Plain Layout

	public int Area { get { return Length * Length; } }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Main() {
\end_layout

\begin_layout Plain Layout

	Square sq = new Square();
\end_layout

\begin_layout Plain Layout

	sq.Length = 4;
\end_layout

\begin_layout Plain Layout

	Console.WriteLine(sq.Area); // outputs 16
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Properties support get and set methods (both optional), which do not have
 to have the same visibility (it's valid to have a public get and private
 set).
 Properties can also have parameters which turns them into indexers.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class StringIntMap {
\end_layout

\begin_layout Plain Layout

	public int this[string key] { 
\end_layout

\begin_layout Plain Layout

		get { ...; } set { ...; } // assuming a sensible implementation
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Main() {
\end_layout

\begin_layout Plain Layout

	StringIntMap map = new StringIntMap();
\end_layout

\begin_layout Plain Layout

	map["test"] = 1;
\end_layout

\begin_layout Plain Layout

	Console.WriteLine(map["test"]); // outputs 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generics
\end_layout

\begin_layout Standard
The CLI supports parametric polymorphic types via generics types that are
 parametrized on other types (value dependence would allow types to also
 be parametrized on values).
 The MSR White paper 
\begin_inset CommandInset citation
LatexCommand cite
key "ext-vox"

\end_inset

 describes some initial design considerations to do parametric polymorphism
 in COM+ (the original name for what became the CLI and .NET).
 While the final design and implementation that shipped with .NET differs
 slightly from the design presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "ext-vox"

\end_inset

, the paper does give an insight into what we need to be thinking about
 while designing value parametrics.
 It's worth taking some time to look at how generics ended up being specified
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

 and implemented in Mono (due to copyright reasons we can't look at Microsoft’s
 open source CLR code).
\end_layout

\begin_layout Standard
Generics are defined in section II.9 of 
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

.
 A type in the CLI can have a fixed generic arity (that is generics are
 not variadic), the parameters are unnamed and are accessed by index (either
 !0 or for type parameters and !!0 for method parameters).
 Each type parameter may be constrained by a number of properties, including
 constraints on being a value or reference type, having a defined base class
 or interface or being default constructable.
 Type parameters can be value or reference types, this is a marked difference
 from the suggestion in 
\begin_inset CommandInset citation
LatexCommand cite
key "ext-vox"

\end_inset

 which suggested that value types should not be allowed due to having to
 re-JIT the types code for each value type.
\end_layout

\begin_layout Standard
Generics allow the CLI to represent types such as 
\begin_inset Formula $List\left\langle T\right\rangle $
\end_inset

 while retaining run time information such that the run time type of 
\begin_inset Formula $List\left\langle object\right\rangle $
\end_inset

 is different to 
\begin_inset Formula $List\left\langle int\right\rangle $
\end_inset

.
 
\begin_inset Formula $List\left\langle int\right\rangle $
\end_inset

 is also special in that 
\begin_inset Formula $int$
\end_inset

 is a value type and yet the run time can use a 
\begin_inset Formula $List\left\langle int\right\rangle $
\end_inset

without causing excessive boxing of values.
\end_layout

\begin_layout Standard
If we look at the definition of
\begin_inset Formula $List\left\langle T\right\rangle $
\end_inset

in Microsoft’s distribution of .NET 4.0 we can see how the generic parameter
 is declared and used.
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

.class public auto ansi serializable beforefieldinit List`1<T>
\end_layout

\begin_layout Plain Layout

extends System.Object 
\end_layout

\begin_layout Plain Layout

implements System.Collections.Generic.IList`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.Generic.ICollection`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.Generic.IEnumerable`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.IList, 
\end_layout

\begin_layout Plain Layout

	System.Collections.ICollection, 
\end_layout

\begin_layout Plain Layout

	System.Collections.IEnumerable
\end_layout

\begin_layout Plain Layout

{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The declaration 
\begin_inset Formula $.class...List`1\left\langle T\right\rangle $
\end_inset

 declares a new class type with one generic parameter 
\begin_inset Formula $T$
\end_inset

, which has no constraints.
 The implements clause lists a number of interfaces which 
\begin_inset Formula $List$
\end_inset

 implements, the first three of these interfaces are themselves generic.
 On line 3 the 
\begin_inset Formula $System.Collections.Generic.IList`1$
\end_inset

 syntax indicates that we mean the generic 
\begin_inset Formula $IList$
\end_inset

 with one parameter 
\begin_inset Formula $`1$
\end_inset

, while 
\begin_inset Formula $\left\langle !0\right\rangle $
\end_inset

 refers to the first generic class parameter 
\begin_inset Formula $T$
\end_inset

, and passes that as the type argument to 
\begin_inset Formula $IList$
\end_inset

.
\end_layout

\begin_layout Standard
Generic parameters can also be constrained, a run length compressed list
 for example would require that the type it stored had an equality operator.
 The 
\begin_inset Formula $IEquatable\left\langle T\right\rangle $
\end_inset

 interface defines a method 
\begin_inset Formula $bool\; Equal\left(T\; value\right)$
\end_inset

, so if a type 
\begin_inset Formula $T$
\end_inset

 inherits from 
\begin_inset Formula $IEquatable\left\langle T\right\rangle $
\end_inset

 then it can be compared equal to other values of its type.
 Adding the constraint that the first generic parameters has this property
 is shown here.
 Note the 
\begin_inset Formula $(IEquatable`1\left\langle !0\right\rangle )$
\end_inset

 before the 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.class public auto ansi sealed beforefieldinit CompressedList`1<(IEquatable`1<!0>
) T>
\end_layout

\begin_layout Plain Layout

extends System.Object
\end_layout

\begin_layout Plain Layout

implements System.Collections.Generic.IEnumerable`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.IEnumerable
\end_layout

\begin_layout Plain Layout

{
\end_layout

\end_inset


\end_layout

\begin_layout Section
C++ templates
\begin_inset CommandInset label
LatexCommand label
name "sec:Cpp-templates"

\end_inset


\end_layout

\begin_layout Standard
Uses of value templates in C++ looking at the standard library, Boost and
 CML (the Configurable Math Library).
 The standard C++ library uses value templates in a few places including
 
\begin_inset Formula $std::ratio$
\end_inset

, the random number generation library and 
\begin_inset Formula $type\_traits$
\end_inset

.
 The open source Boost
\begin_inset CommandInset citation
LatexCommand cite
key "boost"

\end_inset

 libraries make use of value templates much more, using them in obvious
 ways in the Array library, which is for safer arrays using a new class
 
\begin_inset Formula $Array\left\langle T,N\right\rangle $
\end_inset

, but also scattered throughout the other libraries.
 For example in 
\begin_inset Formula $Spirit::Qi$
\end_inset

, a parser combinator library, the type 
\begin_inset Formula $uint\_parser$
\end_inset

 is templated on the type name of the integer type to return but also on
 the values of the radix and minimum and maximum digits to parse.
 Finally CML
\begin_inset CommandInset citation
LatexCommand cite
key "cmldev"

\end_inset

 uses value templates to define the sizes of vectors and matrices, vector
 is templated on a type name 
\begin_inset Formula $ElementT$
\end_inset

 and 
\begin_inset Formula $StorageT$
\end_inset

.
 Moreover two of the built in storage types (fixed and external) are templated
 on the value of how many elements they store.
 When using these statically sized storage types you get extra static type
 safety that you're not mixing vector sizes in operations.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

cml::vector<float, fixed<3>> a(1,0,0);
\end_layout

\begin_layout Plain Layout

cml::vector<float, fixed<2>> b = a; // compile error
\end_layout

\end_inset


\end_layout

\begin_layout Section
F# units of measure
\begin_inset CommandInset label
LatexCommand label
name "sec:Fsharp-units"

\end_inset


\end_layout

\begin_layout Standard
F# has the ability to markup number values with units of measure that allow
 checking of units at compile time.
 This extra checking can prevent mistakes such as that which brought down
 the Mars Climate Orbiter in 1999 because of a mismatch between Imperial
 and Metric units in force calculation, a very expensive mistake as the
 craft cost $125 million.
 Units of measure are done at compile time and all units information is
 erased from the run time, this means that values cast to 
\begin_inset Formula $Object$
\end_inset

 cannot be recast to a measured type safely at run time, but also that these
 units cannot be exposed as part of a public interface to be consumed by
 other CLI languages such as C# or VB.
\end_layout

\begin_layout Standard
Units of measure are declared as opaque types marked up with the 
\family typewriter

\begin_inset Formula $Measure$
\end_inset


\family default
 attribute.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[<Measure>] type meter
\end_layout

\end_inset

Units of measure can also be declared as equal to other units, for example
 milliliters as cubic centimeters.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[<Measure>] type ml = cm^3
\end_layout

\end_inset

The normal unit operators such as multiplication, division and powers are
 usable and can be worked out by the type inference engine.
 For example in the following, code type inference correctly identifies
 
\family typewriter

\begin_inset Formula $distance$
\end_inset


\family default
 as type 
\begin_inset Formula $float\left\langle meter\right\rangle $
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

let speed = 55.0<meter/second>
\end_layout

\begin_layout Plain Layout

let time = 3.5<second>
\end_layout

\begin_layout Plain Layout

let distance = speed * time;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

speed    : float<meter/second>
\end_layout

\begin_layout Plain Layout

time     : float<second>
\end_layout

\begin_layout Plain Layout

distance : float<meter>
\end_layout

\end_inset

The compiler will normalize units of measure to a standard form, from the
 MSDN documentation
\begin_inset CommandInset citation
LatexCommand cite
key "fsharp-units-of-measure"

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Unit formulas that mean the same thing can be written in various equivalent
 ways.
 Therefore, the compiler converts unit formulas into a consistent form,
 which converts negative powers to reciprocals, groups units into a single
 numerator and a denominator, and alphabetizes the units in the numerator
 and denominator.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Units of measure are a common praise of F# and provided a valuable case
 study for us to use in our type system extension.
 While units of measure is implemented in F# as a sort separate from the
 standard types they behave somewhat like values of a standard type (with
 operations for multiplication and division).
 A system that allowed them to be values of a Measure type (rather than
 a separate sort) while retaining the current features (including inference)
 would be impressive.
\end_layout

\begin_layout Section
Path dependent types
\begin_inset CommandInset label
LatexCommand label
name "sec:Path-dependent-types"

\end_inset


\end_layout

\begin_layout Standard
Path dependent types like those found in Scala are similar to value dependent
 types in that they depend on the value of the object that created them,
 but they are not as general.
 An example of path dependence in Scala is the following Board and Coordinate
 example
\begin_inset CommandInset citation
LatexCommand cite
key "stack-2693067"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{
\end_layout

\begin_layout Plain Layout

language=scala,
\end_layout

\begin_layout Plain Layout

breaklines=true,
\end_layout

\begin_layout Plain Layout

basicstyle=
\backslash
footnotesize,
\end_layout

\begin_layout Plain Layout

numbers=left,
\end_layout

\begin_layout Plain Layout

tabsize=2}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

case class Board(length: Int, height: Int) 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

	case class Coordinate(x: Int, y: Int) 
\end_layout

\begin_layout Plain Layout

	{      
\end_layout

\begin_layout Plain Layout

		require(0 <= x && x < length && 0 <= y && y < height)    
\end_layout

\begin_layout Plain Layout

	}   
\end_layout

\begin_layout Plain Layout

	val occupied = scala.collection.mutable.Set[Coordinate]() 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val b1 = Board(20, 20) 
\end_layout

\begin_layout Plain Layout

val b2 = Board(30, 30)
\end_layout

\begin_layout Plain Layout

var b3 = b1
\end_layout

\begin_layout Plain Layout

val c1 = b1.Coordinate(15, 15) 
\end_layout

\begin_layout Plain Layout

val c2 = b2.Coordinate(25, 25) 
\end_layout

\begin_layout Plain Layout

b1.occupied += c1 
\end_layout

\begin_layout Plain Layout

b2.occupied += c2
\end_layout

\begin_layout Plain Layout

b3.occupied += c1
\end_layout

\begin_layout Plain Layout

// Next line doesn't compile 
\end_layout

\begin_layout Plain Layout

b1.occupied += c2
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

Here the type of 
\begin_inset Formula $c1$
\end_inset

 and 
\begin_inset Formula $c2$
\end_inset

 depend on the values 
\begin_inset Formula $b1$
\end_inset

 and 
\begin_inset Formula $b2$
\end_inset

.
 Not that it is in fact the values not these specific identifiers that are
 the dependence, as shown on line 17.
 Path dependence in the type system does not allow line 19, which is stricter
 than just inner classes in Java.
 
\end_layout

\begin_layout Standard
Path dependence is an extension of the fact that in Scala and Java inner
 classes are created via an instance of the outer class and maintain a reference
 to their creator.
 I call the creation via an instance of the outer class an instance inner
 types, as opposed to static inner types that do not require an instance
 of the outer class.
 The CLI does not support path dependent types or instance inner types,
 the only difference between inner and outer class in the CLI is viability
 (that is an inner class can be made private and thus only be accessed by
 the outer class).
 While it's possible to require a reference to the outer class as part of
 the inner class's constructor it is not a requirement.
 While instance created inner classes and then path dependence could be
 added at the language level this leads to the risk that Scala ran into
 where the virtual machine reflection system no longer resembled the language
 type system, thus pushing for the implementation of a whole new reflection
 system to be built.
 
\end_layout

\begin_layout Standard
Therefore if we are to investigate the addition of adding path dependent
 types we also need to add instance inner types to the CLI.
 Alternatively we could try to design value dependence such that the following
 was possible.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{
\end_layout

\begin_layout Plain Layout

language=c++,
\end_layout

\begin_layout Plain Layout

breaklines=true,
\end_layout

\begin_layout Plain Layout

basicstyle=
\backslash
footnotesize,
\end_layout

\begin_layout Plain Layout

tabsize=2}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

class Board
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int length, height;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Board(int length, int height)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.length = length;
\end_layout

\begin_layout Plain Layout

		this.height = height;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	class Coordianate<Board b>
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		public Coordinate(int x, int y)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			require(0 <= x && x < b.length && 0 <= y && y < b.height)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Set<Coordianate<this>> occupied = new Set<Coordinate<this>>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Allowing the value parameter to be any type is much more general than path
 dependence, In this case 
\begin_inset Formula $Coordianate$
\end_inset

 would not even need to be an inner class of 
\begin_inset Formula $Board$
\end_inset

.
 However  this is a very ambitious addition and if it's even possible is
 uncertain.
\end_layout

\begin_layout Section
Virtual types
\begin_inset CommandInset label
LatexCommand label
name "sec:Virtual-types"

\end_inset


\end_layout

\begin_layout Standard
Virtual types are also found in Scala, they allow a subclass to override
 a type variable in the super class.
 In the following example the type T declared in class A is made more specific
 in the subclass B.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

class A
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	type T
\end_layout

\begin_layout Plain Layout

	abstract T foo();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class B 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	override type T = String
\end_layout

\begin_layout Plain Layout

	override T foo() { return "string"; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While virtual types can be useful everything they accomplish can also be
 done with generics, albeit with sometime much more syntax.
 
\begin_inset CommandInset citation
LatexCommand cite
key "staticvts"

\end_inset

 shows how the same program can be expressed with virtual types or parametrized
 types.
 While one way is often more elegant than the other you gain little in supportin
g both.
 As parametrized types are already supported by the CLI virtual types are
 not hugely interesting.
\end_layout

\begin_layout Section
First class types
\end_layout

\begin_layout Standard
Cayenne
\begin_inset CommandInset citation
LatexCommand cite
key "cayenne"

\end_inset

 is a language with support for dependent types and first class types (i.e.
 types can be be used like values).
 As Cayenne is a functional language inspired by Haskell, it's unlikely
 we can lift ideas straight from it to be used in the CLI, however it provides
 an example of a very general dependent types system.
 Two core features of Cayenne are dependent functions and dependent records.
 Dependent functions allow a function return type to depend on the value
 of the parameter, as shown in the following example from 
\begin_inset CommandInset citation
LatexCommand cite
key "cayenne"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

printfType :: String -> #
\end_layout

\begin_layout Plain Layout

PrintfType "" = String
\end_layout

\begin_layout Plain Layout

PrintfType ('%':'d':cs) = Int    -> PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType ('%':'s':cs) = Stirng -> PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType ('%':_:cs)   =           PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType (_:cs)       =           PrintfType cs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

printf :: (fmt::String) -> PrintfType fmt
\end_layout

\begin_layout Plain Layout

printf fmt = pr fmt ""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pr :: (fmt::String) -> String -> PrintfType fmt
\end_layout

\begin_layout Plain Layout

pr "" res = res
\end_layout

\begin_layout Plain Layout

pr ('%':'d':cs) res = 
\backslash
(i::Int) -> pr cs (res ++ show i)
\end_layout

\begin_layout Plain Layout

pr ('%':'s':cs) res = 
\backslash
(s::String) -> pr cs (res ++ s)
\end_layout

\begin_layout Plain Layout

pr ('%':c:cs) res   = pr cs (res ++ [c])
\end_layout

\begin_layout Plain Layout

pr (c:cs) res       = pr css (res ++ [c])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example the type of 
\begin_inset Formula $printf$
\end_inset

depends on the value of the parameter fmt.
 This also shows how types and values are treated equally in Cayenne.
 The type 
\begin_inset Formula $\#$
\end_inset

 is the type of all types (normal notation is 
\begin_inset Formula $*$
\end_inset

 but 
\begin_inset Formula $\#$
\end_inset

 was chosen to avoid clashes with the infix operator 
\begin_inset Formula $*$
\end_inset

).
 
\end_layout

\begin_layout Section
Generalized algebraic data types
\end_layout

\begin_layout Standard
Generalized algebraic data types (GADTs) are predominately a feature of
 functional languages.
 The use of GADTs in object orientated languages is less common but 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 shows how all GADT programs can be expressed in C# and that with some small
 modifications to the language be easily supported.
 The two modifications proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 are an extension of the switch statement and an extension of generic constraint
s.
 
\end_layout

\begin_layout Standard
The extension to generic constraints would allow equality constraints on
 generic types, section 3.1 (Equational constraints for C#) of 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 describes this extension.
 This would allow a generic type to be declared equal to another type, this
 would be checked statically at compile time.
 For example a list flatten method could check that the list was a list
 of lists.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

public abstract classt List<T> {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	public abstract List<T> Append(List<T> list);
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() where T=List<U>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Nil<T> : List<T> {
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return new Nil<U>;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Cons<T> : List<T> {	
\end_layout

\begin_layout Plain Layout

	T head; List<T> tail;
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return this.head.Append(this.tail.Flatten());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calling 
\begin_inset Formula $Flatten$
\end_inset

 on a 
\begin_inset Formula $List\left\langle T\right\rangle $
\end_inset

 would statically check that 
\begin_inset Formula $T=List\left\langle U\right\rangle $
\end_inset

 where 
\begin_inset Formula $U$
\end_inset

 is any type.
 Thus in the method body of flatten we can assume that the type of 
\begin_inset Formula $head$
\end_inset

 is 
\begin_inset Formula $List\left\langle U\right\rangle $
\end_inset

 which has an 
\begin_inset Formula $Append$
\end_inset

 method.
 While the paper suggests this as a C# extension generic constraints are
 currently encoded at the CLI level and so we could add this as a CLI extension,
 thus allowing this to be added to C# and other languages easily.
 
\end_layout

\begin_layout Standard
The second proposal is an extension to the switch statement to allow switching
 on types, binding type variables in switch case clauses and matching multiple
 expressions.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

switch (e1, e2)
\end_layout

\begin_layout Plain Layout

	case (Lit x, Lit y):
\end_layout

\begin_layout Plain Layout

		return x.value == y.value;
\end_layout

\begin_layout Plain Layout

	case (Tuple<A,B> x, Tuple<C,D> y):
\end_layout

\begin_layout Plain Layout

		return Eq(x.fst, y.fst) && Eq(x.snd, y.snd);
\end_layout

\begin_layout Plain Layout

	default:
\end_layout

\begin_layout Plain Layout

		returna false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While switch statements are a language feature (at the CLI level they are
 encoded the same as multiple if statements) the authors point out that
 support at the CLI level for a match-and-bind primitive would be useful
 (see the end of section 3.4 in 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

).
\end_layout

\begin_layout Chapter
Project plan
\end_layout

\begin_layout Standard
As already briefly mentioned in the introduction this project can be split
 into three major parts.
 
\end_layout

\begin_layout Section
Investigation
\end_layout

\begin_layout Standard
The first part of the project is an investigation into value dependent types
 and similar systems.
 This has already been covered somewhat in our background research.
 An understanding of how these systems are useful and how they can be designed
 and implemented will be used to guide us on the design of the CLI extension.
 This investigation will form the background research part of the final
 report and will be mostly done as part of the interim report due January
 the 15th.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
The second part of the project is to design an extension to the CLI that
 supports dependent types.
 Exactly what would be supported in this new system will depend on where
 are investigation has taken us.
 We will show what changes need to be made to ECMA-335 to support the extension.
 To allow time to work on an implementation the design should be completed
 by the April 22nd, giving us two months to work on the implementation.
 If an implementable design is not possible then those two months will be
 used to document why this is so.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The last part of the project is to implement the extension.
 We will be using the open source Mono project for this.
 This will require us to change both the run time and the assembler, to
 support the new syntax.
 This will be completed by the project deadline of June 18th.
\end_layout

\begin_layout Chapter
Evaluation plan
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
Defining semantics for what value dependence means can be done in two ways.
 Firstly we could extend the ECMA specification (
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

).
 Secondly we could take a formal specification of the CLI and extend that.
 While work has been done on formalization of CLI languages such as C#,
 work on formalizing the CLI does not seem to have been done.
 If we can work out how value dependence should work in the CLI then extending
 the ECMA specification is a required aim, as it is the basis for compiler
 writers targeting the CLI.
 Extending a formal specification would be a stretch goal to complete once
 other goals are achieved, both because it may require translating our extension
 to C# to use a lightweight C# formalization based on featherweight GJ and
 secondly as a formalization is not required for the implementation work.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
Given an extension to the CLI specification we want to show that the extension
 can be implemented.
 To do this we will extend the open source Mono run time to support value
 dependent types.
 The most important aspect is correctness but performance should be kept
 in mind.
 As pointed out in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Performance"

\end_inset

 we want certain performance characteristics out of the system.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "report"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
