#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{url}
\usepackage{listings}

% "define" Scala
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic true
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Value dependent types for the CLI
\end_layout

\begin_layout Author
Fraser Waters
\begin_inset Foot
status open

\begin_layout Plain Layout
fraser.waters08@imperial.ac.uk
\end_layout

\end_inset


\end_layout

\begin_layout Date
11/05/12
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
One of the main motivations for looking into value dependence is for numeric
 types such as Vector3, Vector4, Matrix3x4.
 These are used for graphics and physics applications where most vectors
 and matrices in the problem domain are small (3 or 4 elements).
 Currently there is no nice way to represent all the different sizes for
 types like this in C# (or any other CLI language).
 Consequently it lead me to the creation of a numeric type generator, a
 separate program that outputs the source code for a pre defined set of
 configurations (currently Vector2 to Vector8 and Matrix2x2 up to Matrix4x4).
 While the use of these types is mostly acceptable extending them is difficult.
 The following shows the code used to generate all the required dot product
 functions currently, and how I imagine it might look with value dependence.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WriteLine("/// <summary>");             
\end_layout

\begin_layout Plain Layout

WriteLine("/// Calculates the dot product (inner product) of two vectors.");
             WriteLine("/// </summary>");             
\end_layout

\begin_layout Plain Layout

WriteLine("/// <param name=
\backslash
"left
\backslash
">First source vector.</param>");             
\end_layout

\begin_layout Plain Layout

WriteLine("/// <param name=
\backslash
"right
\backslash
">Second source vector.</param>");             
\end_layout

\begin_layout Plain Layout

WriteLine("/// <returns>The dot product of the two vectors.</returns>");
             
\end_layout

\begin_layout Plain Layout

if (!Type.IsCLSCompliant) { WriteLine("[CLSCompliant(false)]"); }       
      
\end_layout

\begin_layout Plain Layout

WriteLine("public static float Dot({0} left, {0} right)", Name);       
      
\end_layout

\begin_layout Plain Layout

WriteLine("{");             
\end_layout

\begin_layout Plain Layout

Indent();
\end_layout

\begin_layout Plain Layout

var dotproduct = 	string.Join("+",
\end_layout

\begin_layout Plain Layout

	Components.Select(component => string.Format("left[{0}]*right[{0}]", component)))
;
\end_layout

\begin_layout Plain Layout

WriteLine("return {0};", dotproduct);             
\end_layout

\begin_layout Plain Layout

Dedent();
\end_layout

\begin_layout Plain Layout

WriteLine("}");
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static float Dot<int n>(Vector<n> a, Vector<n> b)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	float dot = 0;
\end_layout

\begin_layout Plain Layout

	for(int i=0; i<n; ++i)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		dot += a[i]*b[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return dot;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The usage of these types would remain nearly the same, the following shows
 how they look at the moment compared to what they might look like with
 value dependence.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

var a = new Vector3(1, 1, 1);
\end_layout

\begin_layout Plain Layout

var b = new Vector3(2, 2, 2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var ab = b - a;
\end_layout

\begin_layout Plain Layout

var dot = Vector.Dot(ab, a);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = new Vector<3>(1, 1, 1);
\end_layout

\begin_layout Plain Layout

var b = new Vector<3>(2, 2, 2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var ab = b - a;
\end_layout

\begin_layout Plain Layout

var dot = Vector.Dot(ab, a);
\end_layout

\end_inset


\end_layout

\begin_layout Section
Performance
\end_layout

\begin_layout Standard
Currently we can we can define an interface 
\family typewriter
Vector
\family default
 that defines the indexing operator and length property, and then write
 functions useing this interface.
 This saves us the effort of creating and maintaining the generator but
 at the cost of run time performance.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

interface Vector
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int Length { get; }
\end_layout

\begin_layout Plain Layout

	float this[int index] { get; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public static float Dot<T>(T a, T b) where T : Vector
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	float dot = 0;
\end_layout

\begin_layout Plain Layout

	for(int i=0; i<a.Length; ++i)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		dot += a[i]*b[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return dot;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Vector-performance"

\end_inset

The issue with this (and this give some suggestions as to how we would want
 to implement dependent types) is that it adds an extra instance variable
 to each vector and means that the loop cannot be unrolled.
 For high performance code that theses small vector types are supposed to
 be used for that's an unacceptable trade off.
 With dependent types we could write code in a similar way but with better
 performance characteristics.
\end_layout

\begin_layout Standard
While these vector types are the main motivator for value dependence there
 are more uses for value dependent types, we explore these in the background
 section.
\end_layout

\begin_layout Section
Value dependent types
\end_layout

\begin_layout Standard
Dependent types allow static typing of expression based on values rather
 than just other types.
 There are some functional languages such as Agda, Coq and Idris that support
 dependent types, but in object oriented languages dependent types are not
 so common.
 While fully general value dependent types are rare, some weaker versions,
 including path dependent types and virtual types, are used in some mainstream
 languages.
 Notably Scala supports both path dependence and virtual types, F# supports
 units of measure allowing numbers to be typed based on a unit value, and
 C++ has templates that can be parametrized on values.
\end_layout

\begin_layout Section
The CLI
\begin_inset Foot
status open

\begin_layout Plain Layout
Common Language Infrastructure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The CLI is a specification for a virtual execution environment, that is
 implemented by Microsoft’s CLR (often confused with the .NET branding) and
 the open source Mono project.
 It is targeted by VB, C#, F#, IronPython and other languages.
 It retains a high level of type information, more so than the Java Virtual
 Machine (which for example has no concept of generic types despite Java
 supporting them).
 
\end_layout

\begin_layout Standard
The ability to retain high level type information allows easy interoperability
 between separate CLI modules, even with modules compiled using different
 languages.
 This feature starts to fall apart when languages add typing extensions
 that aren't supported by the CLI.
 Units of measure in F#, for example, are erased at compile time meaning
 that other modules which consume an F# module where units of measure were
 used cannot see the units.
 This loss of typing information is not ideal, as it reduces interoperability,
 and so prompts us to consider adding value dependence as a CLI feature
 and not just an extension to a current CLI language such as C# or F#.
 If units can be written in terms of dependent types then we can 
\emph on
fix
\emph default
 them, else at least our extension does not suffer the same problem of interoper
ability.
 Of course any new features added to the CLI should be backwards compatible
 and efficient, we need to keep in mind the size of the new types and their
 instances, the size of the byte code and the speed to process it and the
 speed and size of the JITed code.
\end_layout

\begin_layout Section
Project
\end_layout

\begin_layout Standard
This project will investigate value dependent types in the CLI.
 It will be split into 3 parts.
 
\end_layout

\begin_layout Enumerate
To investigate the use and benefits of value dependent typing.
\end_layout

\begin_layout Enumerate
To show how value dependent types could be added to the CLI, preferably
 in a clean and backwards compatible way.
\end_layout

\begin_layout Enumerate
If part 2 is successful to implement value dependent typing in Mono.
 
\end_layout

\begin_layout Enumerate
If part 2 is unsuccessful then an through explanation of why it can't be
 done should be written.
\end_layout

\begin_layout Part
Background
\end_layout

\begin_layout Section
The CLI
\end_layout

\begin_layout Subsection
Common intermediate language
\end_layout

\begin_layout Standard
The CLI runs Common Intermediate Language (CIL) byte code.
 CIL is a type rich, stack based assembly language.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.assembly Hello {} 
\end_layout

\begin_layout Plain Layout

.assembly extern mscorlib {} 
\end_layout

\begin_layout Plain Layout

.method static void Main() 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	.entrypoint     
\end_layout

\begin_layout Plain Layout

	.maxstack 1     
\end_layout

\begin_layout Plain Layout

	ldstr "Hello, world!"     
\end_layout

\begin_layout Plain Layout

	call void [mscorlib]System.Console::WriteLine(string)     
\end_layout

\begin_layout Plain Layout

	ret 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
CIL supports many features not common the low level assembly code.
 As well as basic operations such as add, jump, load, store, operations
 such as field access, method call, object creation, casting etc all have
 CIL instructions.
\end_layout

\begin_layout Subsection
Generics
\end_layout

\begin_layout Standard
The CLI supports parametric polymorphic types via generics types that are
 parametrized on other types (value dependence would allow types to also
 be parametrized on values).
 The MSR White paper 
\begin_inset CommandInset citation
LatexCommand cite
key "ext-vox"

\end_inset

 describes some initial design considerations to do parametric polymorphism
 in COM+ (the original name for what became the CLI and .NET).
 While the final design and implementation differs slightly from this paper
 it gives an insight into what we need to be thinking about while designing
 value parametric.
 It's worth taking some time to look at how generics ended up being specified
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

 and implemented in Mono (due to copyright reasons we can't look at Microsoft’s
 open source CLR code).
\end_layout

\begin_layout Standard
Generics are defined in section II.9 of 
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

.
 A type in the CLI can have a fixed generic arity (that is generics are
 not variadic), the parameters are unnamed and are accessed by index (either
 !0 or for type parameters and !!0 for method parameters).
 Each type parameter may be constrained by a number of properties, including
 constraints on being a value or reference type, having a defined base class
 or interface or being default constructable.
 Type parameters can be value or reference types, this is a marked difference
 from the suggestion in 
\begin_inset CommandInset citation
LatexCommand cite
key "ext-vox"

\end_inset

 which suggested that value types should not be allowed due to having to
 re-JIT the types code for each value type.
\end_layout

\begin_layout Standard
Generics allow the CLI to represent types such as 
\begin_inset Formula $List\left\langle T\right\rangle $
\end_inset

 while retaining run time information such that the run time type of 
\begin_inset Formula $List\left\langle object\right\rangle $
\end_inset

 is different to 
\begin_inset Formula $List\left\langle int\right\rangle $
\end_inset

.
 
\begin_inset Formula $List\left\langle int\right\rangle $
\end_inset

 is also special in that 
\begin_inset Formula $int$
\end_inset

 is a value type and yet the run time can use a 
\begin_inset Formula $List\left\langle int\right\rangle $
\end_inset

without causing excessive boxing of values.
\end_layout

\begin_layout Standard
If we look at the definition of
\begin_inset Formula $List\left\langle T\right\rangle $
\end_inset

in Microsoft’s distribution of .NET 4.0 we can see how the generic parameter
 is declared and used.
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

.class public auto ansi serializable beforefieldinit List`1
\end_layout

\begin_layout Plain Layout

extends System.Object 
\end_layout

\begin_layout Plain Layout

implements System.Collections.Generic.IList`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.Generic.ICollection`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.Generic.IEnumerable`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.IList, 
\end_layout

\begin_layout Plain Layout

	System.Collections.ICollection, 
\end_layout

\begin_layout Plain Layout

	System.Collections.IEnumerable
\end_layout

\begin_layout Plain Layout

{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The declaration 
\begin_inset Formula $.class...List`1$
\end_inset

 declares a new class type with one generic parameter, which has no constraints.
 The implements clause lists a number of interfaces which 
\begin_inset Formula $List$
\end_inset

 implements, the first three of these interfaces are themselves generic.
 On line 3 the 
\begin_inset Formula $System.Collections.Generic.IList`1$
\end_inset

 syntax indicates that we mean the generic 
\begin_inset Formula $IList$
\end_inset

 with one parameter 
\begin_inset Formula $`1$
\end_inset

, 
\begin_inset Formula $\left\langle !0\right\rangle $
\end_inset

 refers to the first generic class parameter, and passes that as the type
 argument to 
\begin_inset Formula $IList$
\end_inset

.
\end_layout

\begin_layout Section
C++
\end_layout

\begin_layout Standard
Uses of value templates in C++ looking at the standard library, Boost and
 CML (the Configurable Math Library).
 The standard C++ library uses value templates in a few places including
 
\begin_inset Formula $std::ratio$
\end_inset

, the random number generation library and 
\begin_inset Formula $type\_traits$
\end_inset

.
 The open source Boost
\begin_inset CommandInset citation
LatexCommand cite
key "boost"

\end_inset

 libraries make use of value templates much more, using them in obvious
 ways in the Array library, which is for safer arrays using a new class
 
\begin_inset Formula $Array\left\langle T,N\right\rangle $
\end_inset

, but also scattered throughout the other libraries.
 For example in 
\begin_inset Formula $Spirit::Qi$
\end_inset

, a parser combinator library, the type 
\begin_inset Formula $uint\_parser$
\end_inset

 is templated on the type name of the integer type to return but also on
 the values of the radix and minimum and maximum digits to parse.
 Finally CML
\begin_inset CommandInset citation
LatexCommand cite
key "cmldev"

\end_inset

 uses value templates to define the sizes of vectors and matrices, vector
 is templated on a type name 
\begin_inset Formula $ElementT$
\end_inset

 and 
\begin_inset Formula $StorageT$
\end_inset

.
 Moreover two of the built in storage types (fixed and external) are templated
 on the value of how many elements they store.
 When using these statically sized storage types you get extra static type
 safety that you're not mixing vector sizes in operations.
\end_layout

\begin_layout Section
F#
\end_layout

\begin_layout Standard
F# has the ability to markup number values with units of measure that allow
 checking of units at compile time.
 This extra checking can prevent mistakes such as that which brought down
 the Mars Climate Orbiter in 1999 because of a mismatch between Imperial
 and Metric units in force calculation, a very expensive mistake as the
 craft cost $125 million.
 Units of measure is done at compile time and all units information is erased
 from the run time, this means that values cast to 
\begin_inset Formula $Object$
\end_inset

 cannot be recast to a measured type safely at run time, but also that these
 units cannot be exposed as part of an public interface to be consumed by
 other CLI languages such as C# or VB.
\end_layout

\begin_layout Standard
Units of measure are declared as opaque types marked up with the 
\family typewriter

\begin_inset Formula $Measure$
\end_inset


\family default
 attribute.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[<Measure>] type meter
\end_layout

\end_inset

Units of measure can also be declared as equal to other units, for example
 milliliters as cubic centimeters.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[<Measure>] type ml = cm^3
\end_layout

\end_inset

The normal unit operators such as multiplication, division and powers are
 usable and can be worked out by the type inference engine.
 For example in the following, code type inference correctly identifies
 
\family typewriter

\begin_inset Formula $distance$
\end_inset


\family default
 as type 
\begin_inset Formula $float\left\langle meter\right\rangle $
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

let speed = 55.0<meter/second>
\end_layout

\begin_layout Plain Layout

let time = 3.5<second>
\end_layout

\begin_layout Plain Layout

let distance = speed * time;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

speed    : float<meter/second>
\end_layout

\begin_layout Plain Layout

time     : float<second>
\end_layout

\begin_layout Plain Layout

distance : float<meter>
\end_layout

\end_inset

The compiler will normalize units of measure to a standard form, from the
 MSDN documentation
\begin_inset CommandInset citation
LatexCommand cite
key "fsharp-units-of-measure"

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Unit formulas that mean the same thing can be written in various equivalent
 ways.
 Therefore, the compiler converts unit formulas into a consistent form,
 which converts negative powers to reciprocals, groups units into a single
 numerator and a denominator, and alphabetizes the units in the numerator
 and denominator.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Units of measure are a common praise of F# and provided a valuable case
 study for us to use in our type system extension.
\end_layout

\begin_layout Section
Path dependent types
\end_layout

\begin_layout Standard
Path dependent types like those found in Scala are similar to value dependent
 types in that they depend on the value of the object that created them,
 but they are not as general.
 An example of path dependence in Scala is the following Board and Coordinate
 example
\begin_inset CommandInset citation
LatexCommand cite
key "stack-2693067"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{
\end_layout

\begin_layout Plain Layout

language=scala,
\end_layout

\begin_layout Plain Layout

breaklines=true,
\end_layout

\begin_layout Plain Layout

basicstyle=
\backslash
footnotesize,
\end_layout

\begin_layout Plain Layout

numbers=left,
\end_layout

\begin_layout Plain Layout

tabsize=2}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

case class Board(length: Int, height: Int) 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

	case class Coordinate(x: Int, y: Int) 
\end_layout

\begin_layout Plain Layout

	{      
\end_layout

\begin_layout Plain Layout

		require(0 <= x && x < length && 0 <= y && y < height)    
\end_layout

\begin_layout Plain Layout

	}   
\end_layout

\begin_layout Plain Layout

	val occupied = scala.collection.mutable.Set[Coordinate]() 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val b1 = Board(20, 20) 
\end_layout

\begin_layout Plain Layout

val b2 = Board(30, 30)
\end_layout

\begin_layout Plain Layout

var b3 = b1
\end_layout

\begin_layout Plain Layout

val c1 = b1.Coordinate(15, 15) 
\end_layout

\begin_layout Plain Layout

val c2 = b2.Coordinate(25, 25) 
\end_layout

\begin_layout Plain Layout

b1.occupied += c1 
\end_layout

\begin_layout Plain Layout

b2.occupied += c2
\end_layout

\begin_layout Plain Layout

b3.occupied += c1
\end_layout

\begin_layout Plain Layout

// Next line doesn't compile 
\end_layout

\begin_layout Plain Layout

b1.occupied += c2
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

Here the type of 
\begin_inset Formula $c1$
\end_inset

 and 
\begin_inset Formula $c2$
\end_inset

 depend on the values 
\begin_inset Formula $b1$
\end_inset

 and 
\begin_inset Formula $b2$
\end_inset

.
 Not that it is in fact the values not these specific identifiers that are
 the dependence, as shown on line 17.
 Path dependence in the type system does not allow line 19, which is stricter
 than just inner classes in Java.
 
\end_layout

\begin_layout Standard
Path dependence is an extension of the fact that in Scala and Java inner
 classes are created via an instance of the outer class and maintain a reference
 to their creator.
 I call the creation via an instance of the outer class an instance inner
 types, as opposed to static inner types that do not require an instance
 of the outer class.
 The CLI does not support path dependent types or instance inner types,
 the only difference between inner and outer class in the CLI is viability
 (that is an inner class can be made private and thus only be accessed by
 the outer class).
 While it's possible to require a reference to the outer class as part of
 the inner class's constructor it is not a requirement.
 While instance created inner classes and then path dependence could be
 added at the language level this leads to the risk that Scala ran into
 where the virtual machine reflection system no longer resembled the language
 type system, thus pushing for the implementation of a whole new reflection
 system to be built.
 
\end_layout

\begin_layout Standard
Therefore if we are to investigate the addition of adding path dependent
 types we also need to add instance inner types to the CLI.
 Alternatively we could try to design value dependence such that the following
 was possible.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{
\end_layout

\begin_layout Plain Layout

language=c++,
\end_layout

\begin_layout Plain Layout

breaklines=true,
\end_layout

\begin_layout Plain Layout

basicstyle=
\backslash
footnotesize,
\end_layout

\begin_layout Plain Layout

tabsize=2}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

class Board
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int length, height;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Board(int length, int height)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.length = length;
\end_layout

\begin_layout Plain Layout

		this.height = height;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	class Coordianate<Board b>
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		public Coordinate(int x, int y)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			require(0 <= x && x < b.length && 0 <= y && y < b.height)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Set<Coordianate<this>> occupied = new Set<Coordinate<this>>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Allowing the value parameter to be any type is much more general than path
 dependence, In this case 
\begin_inset Formula $Coordianate$
\end_inset

 would not even need to be an inner class of 
\begin_inset Formula $Board$
\end_inset

.
 However  this is a very ambitious addition and if it's even possible would
 require more investigation.
\end_layout

\begin_layout Section
Virtual types
\end_layout

\begin_layout Standard
Virtual types are also found in Scala, they allow a subclass to override
 a type variable in the super class.
 In the following example the type T declared in class A is made more specific
 in the subclass B.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

class A
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	type T
\end_layout

\begin_layout Plain Layout

	abstract T foo();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class B 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	override type T = String
\end_layout

\begin_layout Plain Layout

	override T foo() { return "string"; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While virtual types can be useful everything they accomplish can also be
 done with generics, albeit with sometime much more syntax.
 
\begin_inset CommandInset citation
LatexCommand cite
key "staticvts"

\end_inset

 shows how the same program can be expressed with virtual types or parametrized
 types.
 While one way is often more elegant than the other you gain little in supportin
g both.
 As parametrized types are already supported by the CLI virtual types are
 not hugely interesting.
\end_layout

\begin_layout Section
First class types
\end_layout

\begin_layout Standard
Cayenne
\begin_inset CommandInset citation
LatexCommand cite
key "cayenne"

\end_inset

 is a language with support for dependent types and first class types (i.e.
 types can be be used like values).
 As Cayenne is a functional language inspired by Haskell, it's unlikely
 we can lift ideas straight from it to be used in the CLI, however it provides
 an example of a very general dependent types system.
 Two core features of Cayenne are dependent functions and dependent records.
 Dependent functions allow a function return type to depend on the value
 of the parameter, as shown in the following example from 
\begin_inset CommandInset citation
LatexCommand cite
key "cayenne"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

printfType :: String -> #
\end_layout

\begin_layout Plain Layout

PrintfType "" = String
\end_layout

\begin_layout Plain Layout

PrintfType ('%':'d':cs) = Int    -> PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType ('%':'s':cs) = Stirng -> PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType ('%':_:cs)   =           PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType (_:cs)       =           PrintfType cs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

printf :: (fmt::String) -> PrintfType fmt
\end_layout

\begin_layout Plain Layout

printf fmt = pr fmt ""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pr :: (fmt::String) -> String -> PrintfType fmt
\end_layout

\begin_layout Plain Layout

pr "" res = res
\end_layout

\begin_layout Plain Layout

pr ('%':'d':cs) res = 
\backslash
(i::Int) -> pr cs (res ++ show i)
\end_layout

\begin_layout Plain Layout

pr ('%':'s':cs) res = 
\backslash
(s::String) -> pr cs (res ++ s)
\end_layout

\begin_layout Plain Layout

pr ('%':c:cs) res   = pr cs (res ++ [c])
\end_layout

\begin_layout Plain Layout

pr (c:cs) res       = pr css (res ++ [c])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example the type of 
\begin_inset Formula $printf$
\end_inset

depends on the value of the parameter fmt.
 This also shows how types and values are treated equally in Cayenne.
 The type 
\begin_inset Formula $\#$
\end_inset

 is the type of all types (normal notation is 
\begin_inset Formula $*$
\end_inset

 but 
\begin_inset Formula $\#$
\end_inset

 was chosen to avoid clashes with the infix operator 
\begin_inset Formula $*$
\end_inset

).
 
\end_layout

\begin_layout Section
Generalized algebraic data types
\end_layout

\begin_layout Standard
Generalized algebraic data types (GADTs) are predominately a feature of
 functional languages.
 The use of GADTs in object orientated languages is less common but 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 shows how all GADT programs can be expressed in C# and that with some small
 modifications to the language be easily supported.
 The two modifications proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 are an extension of the switch statement and an extension of generic constratin
ts.
 
\end_layout

\begin_layout Standard
The extension to generic constraints would allow equality constraints on
 generic types, section 3.1 (Equational constraints for C#) of 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 describes this extension.
 This would allow a generic type to be declared equal to another type, this
 would be checked staticly at compile time.
 For example a list flatten method could check that the list was a list
 of lists.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

public abstract classt List<T> {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	public abstract List<T> Append(List<T> list);
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() where T=List<U>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Nil<T> : List<T> {
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return new Nil<U>;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Cons<T> : List<T> {	
\end_layout

\begin_layout Plain Layout

	T head; List<T> tail;
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return this.head.Append(this.tail.Flatten());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calling 
\begin_inset Formula $Flatten$
\end_inset

 on a 
\begin_inset Formula $List\left\langle T\right\rangle $
\end_inset

 would staticly check that 
\begin_inset Formula $T=List\left\langle U\right\rangle $
\end_inset

 where 
\begin_inset Formula $U$
\end_inset

 is any type.
 Thus in the method body of flatten we can assume that the type of 
\begin_inset Formula $head$
\end_inset

 is 
\begin_inset Formula $List\left\langle U\right\rangle $
\end_inset

 which has an 
\begin_inset Formula $Append$
\end_inset

 method.
 While the paper suggests this as a C# extension generic constraints are
 currently encoded at the CLI level and so we could add this as a CLI extension,
 thus allowing this to be added to C# and other langauges easily.
 
\end_layout

\begin_layout Standard
The second proposal is an extesnion to the switch statement to allow switching
 on types, binding type variables in switch case clauses and matching multiple
 expressions.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

switch (e1, e2)
\end_layout

\begin_layout Plain Layout

	case (Lit x, Lit y):
\end_layout

\begin_layout Plain Layout

		return x.value == y.value;
\end_layout

\begin_layout Plain Layout

	case (Tuple<A,B> x, Tuple<C,D> y):
\end_layout

\begin_layout Plain Layout

		return Eq(x.fst, y.fst) && Eq(x.snd, y.snd);
\end_layout

\begin_layout Plain Layout

	default:
\end_layout

\begin_layout Plain Layout

		returna false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While switch statements are a language feature (at the CLI level they are
 encoded the same as multiple if statements) the authors point out that
 support at the CLI level for a match-and-bind primative would be useful
 (see the end of section 3.4 in 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

).
\end_layout

\begin_layout Part
Project plan
\end_layout

\begin_layout Standard
As already briefly mentioned in the introduction this project can be split
 into three major parts.
 
\end_layout

\begin_layout Section
Investigation
\end_layout

\begin_layout Standard
The first part of the project is an investigation into value dependent types
 and similar systems.
 This has already been covered somewhat in our background research.
 An understanding of how these systems are useful and how they can be designed
 and implemented will be used to guide us on the design of the CLI extension.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
The second part of the project is to design an extension to the CLI that
 supports dependent types.
 Exactly what would be supported in this new system will depend on where
 are investigation has taken us.
 We will show what changes need to be made to ECMA-335 to support the extension.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The last part of the project is to implement the extension.
 We will be using the open source Mono project for this.
 This will require us to change both the run time and the assembler, to
 support the new syntax.
\end_layout

\begin_layout Part
Evaluation plan
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
Defining semantics for what value dependence means can be done in two ways.
 Firstly we could extend the ECMA specification, which is written in formal
 specification speak.
 Secondly we could take a formal specification of the CLI and extend that.
 If we can work out how value dependence should work in the CLI then extending
 the ECMA specification is a required aim.
 Extending a formal specification would be a stretch goal to complete once
 other goals are achieved.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
Given an extension to the CLI specification we want to show that the extension
 can be implemented.
 To do this we will extend the open source Mono run time to support value
 dependent types.
 The most important aspect is correctness but performance should be kept
 in mind.
 As pointed out in 
\begin_inset CommandInset ref
LatexCommand ref
reference "Vector-performance"

\end_inset

 we want certain performance characteristics out of the system.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "report"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
