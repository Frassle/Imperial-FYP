#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{amsmath,amssymb,dot2texi,tikz,hyperref,enumitem}
\usetikzlibrary{shapes,arrows}

\usepackage[T1]{fontenc}
\usepackage[sc]{mathpazo}
\usepackage{fullpage}

\usepackage{color}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{url}
\usepackage{listings}

\lstdefinelanguage{sharpc}{language=[Sharp]C}

% "define" Scala
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\usepackage{caption}
\DeclareCaptionFont{black}{\color{black}}

\DeclareCaptionFormat{listing}{%
  \parbox{\textwidth}{\fbox{\parbox{\textwidth}{#1#2#3}}\vskip4pt}}

\captionsetup[lstlisting]{format=listing,labelfont=black,textfont=black}
\lstset{frame=single,xleftmargin=\fboxsep,xrightmargin=-\fboxsep}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic true
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

%Upper part of the page 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.50
\backslash
textwidth]{imperial_crest_colour.jpg}
\backslash

\backslash
[1cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
LARGE Imperial College London}
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Interim Report}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout

% Title 
\end_layout

\begin_layout Plain Layout


\backslash
HRule 
\backslash

\backslash
[0.4cm] 
\end_layout

\begin_layout Plain Layout

{ 
\backslash
huge 
\backslash
bfseries Value dependent types for the CLI}
\backslash

\backslash
[0.4cm]
\end_layout

\begin_layout Plain Layout


\backslash
HRule 
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout

% Author and supervisor 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Author:}
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Fraser 
\backslash
textsc{Waters}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
href{mailto:fraser.waters08@imperial.ac.uk}{fraser.waters08@imperial.ac.uk} 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushright} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Supervisor:} 
\backslash

\backslash
 Professor Sophia 
\backslash
textsc{Drossopoulou} 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushright} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Bottom of the page 
\end_layout

\begin_layout Plain Layout

{
\backslash
large 
\backslash
today}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Abstract
Value dependent types are a powerful extension to type systems allowing
 types to be parametrized by terms.
 This project looks into how value dependent types could be introduced to
 the CLI, the underlying virtual machine specification for C#, Visual Basic,
 F# and many other languages, to allow more programs to be succinctly expressed
 at the CLI level and exposed to these languages.
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Value dependent types
\end_layout

\begin_layout Standard
Dependent types allow expression to be statically typed based on values;
 rather like how parametric types can be based on other types.
 There are some functional languages such as Agda
\begin_inset CommandInset citation
LatexCommand cite
key "agda"

\end_inset

, Coq
\begin_inset CommandInset citation
LatexCommand cite
key "coq"

\end_inset

, Idris
\begin_inset CommandInset citation
LatexCommand cite
key "idris"

\end_inset

 and Cayanne
\begin_inset CommandInset citation
LatexCommand cite
key "cayenne"

\end_inset

 that support dependent types, but in object oriented languages dependent
 types are not so common.
 While fully general value dependent types are rare, some weaker versions,
 including path dependent types (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Path-dependent-types"

\end_inset

) and virtual types (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Virtual-types"

\end_inset

), are used in some mainstream languages.
 Notably Scala
\begin_inset CommandInset citation
LatexCommand cite
key "scala"

\end_inset

 supports both path dependence and virtual types, F#
\begin_inset CommandInset citation
LatexCommand cite
key "fsharp"

\end_inset

 supports units of measure (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Fsharp-units"

\end_inset

) allowing numbers to be typed based on a unit value, and C++ has templates
 (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Cpp-templates"

\end_inset

) that can be parametrized on values.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
One of the main motivations for looking into value dependence is for work
 in graphics and physics applications where most vectors and matrices in
 the problem domain are small (3 or 4 elements, but no reason this couldn't
 scale to many more for other applications).
 Using types such as Vector3, Vector4, Matrix3x4 which are 3 and 4 element
 float vectors and a 3 by 4 float matrix respectively, make writing code
 much easier than working with multiple float variables.
 Currently there is no nice way to represent all the different sizes for
 types like this in C# (or any other CLI language).
 Consequently it lead me to the creation of a numeric type generator, a
 separate program that outputs the source code for a pre defined set of
 configurations (currently Vector2 to Vector8 and Matrix2x2 up to Matrix4x4).
 While the use of these types is mostly acceptable extending them is difficult.
 As shown below using the generator requires writing the code in literal
 strings, these literals can not be checked at compile time for obvious
 mistakes and the IDE does not offer auto completion when writing them,
 the generator has to be run then the emitted code must be compiled to see
 any problems.
 The following shows a section of code used to generate all the required
 dot product functions.
 
\family typewriter
Components
\family default
 is a list of component indices 0, 1, 2 etc.
 
\family typewriter
WriteLine
\family default
 writes a string to the code file using the current indent level, 
\family typewriter
Indent
\family default
 and 
\family typewriter
Dedent
\family default
 increase and decrease the indent level.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

if (!Type.IsCLSCompliant) { WriteLine("[CLSCompliant(false)]"); }       
      
\end_layout

\begin_layout Plain Layout

WriteLine("public static float Dot({0} left, {0} right)", Name);       
      
\end_layout

\begin_layout Plain Layout

WriteLine("{");             
\end_layout

\begin_layout Plain Layout

Indent();
\end_layout

\begin_layout Plain Layout

var dotproduct = string.Join("+", Components.Select(
\end_layout

\begin_layout Plain Layout

	component => string.Format("left[{0}]*right[{0}]", component)));
\end_layout

\begin_layout Plain Layout

WriteLine("return {0};", dotproduct);
\end_layout

\begin_layout Plain Layout

Dedent();
\end_layout

\begin_layout Plain Layout

WriteLine("}");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With value dependence we could write the code directly to be compiled, skipping
 the generator step, and allowing the use of auto complete and faster iteration
 times.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

public static float Dot<int n>(Vector<n> left, Vector<n> right)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	float dot = 0;
\end_layout

\begin_layout Plain Layout

	for(int i=0; i<n; ++i)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		dot += left[i]*right[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return dot;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The usage of these types would remain nearly the same, the following shows
 how they look at the moment compared to what they might look like with
 value dependence.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Current method
\end_layout

\end_inset

var a = new Vector3(1, 1, 1);
\end_layout

\begin_layout Plain Layout

var b = new Vector3(2, 2, 2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var ab = b - a;
\end_layout

\begin_layout Plain Layout

var dot = Vector.Dot(ab, a);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Proposal
\end_layout

\end_inset

var a = new Vector<3>(1, 1, 1);
\end_layout

\begin_layout Plain Layout

var b = new Vector<3>(2, 2, 2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var ab = b - a;
\end_layout

\begin_layout Plain Layout

var dot = Vector.Dot(ab, a);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see there isn't a big difference.
 Users get more benefit with the latter as they can write dependent functions
 that work for any vector size, as opposed to having to use multiple functions
 for different sizes.
\end_layout

\begin_layout Subsection
Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Performance"

\end_inset


\end_layout

\begin_layout Standard
There are ways to avoid the generator step now, however they do not have
 acceptable performance and layout properties to be used.
 
\end_layout

\begin_layout Standard
The simplest way is to define Vector as dynamicly sized (like arrays) this
 loses all static type safety but does mean functions would only have to
 be written once, saving us the effort of creating and maintaining the generator
 but a cost.
 Vector is no longer purely a value type as it will have a reference field
 in it, this changes the semantics from the current vector types (due to
 no user defined copy constructors or assignment operators in the CLI) and
 also makes them more expensive as they are now tracked by the garbage collector.
 It also makes inter operating with native APIs such as OpenGL harder as
 the Vectors will have to be marshaled to correctly copy the elements of
 their internal array to the native API, the current vector types can just
 be pinned and pointer copied.
\end_layout

\begin_layout Standard
Another way is to define an interface 
\family typewriter
Vector
\family default
 that defines the indexing operator and length property, and then write
 functions using this interface.
 However we still need to create concrete types for each vector size which
 requires the generator.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

interface Vector
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int Length { get; }
\end_layout

\begin_layout Plain Layout

	float this[int index] { get; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public static float Dot<T>(T a, T b) where T : Vector
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	float dot = 0;
\end_layout

\begin_layout Plain Layout

	for(int i=0; i<a.Length; ++i)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		dot += a[i]*b[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return dot;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The issue with this interface approach (and this give some suggestion as
 to how we would want to implement dependent types) is that the loop cannot
 be unrolled.
 For high performance code that theses small vector types are supposed to
 be used for that's an unacceptable trade off, especially as we still have
 to maintain the generator anyway.
 With dependent types we could have better performance characteristics and
 with the preferred flat data layout.
 
\end_layout

\begin_layout Standard
While these vector types are the main motivator for value dependence there
 are more uses for value dependent types, we explore these in the background
 section.
\end_layout

\begin_layout Section
The CLI
\begin_inset Foot
status open

\begin_layout Plain Layout
Common Language Infrastructure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The CLI is a specification for a virtual execution environment, that is
 implemented by Microsoft’s CLR
\begin_inset Foot
status open

\begin_layout Plain Layout
Common Language Runtime
\end_layout

\end_inset

 (often confused with the .NET branding) and the open source Mono project.
 It is targeted by VB, C#, F#, IronPython and other languages.
 It retains a high level of type information, more so than the JVM
\begin_inset Foot
status open

\begin_layout Plain Layout
Java Virtual Machine
\end_layout

\end_inset

 (which for example has no concept of generic types despite Java supporting
 them
\begin_inset CommandInset citation
LatexCommand cite
key "jvm-erasure"

\end_inset

).
\end_layout

\begin_layout Standard
As a C# and F# programmer the CLI is a more attractive specification to
 work with.
 The ability to retain high level type information allows easy interoperability
 between separate CLI modules, even with modules compiled using different
 languages.
\end_layout

\begin_layout Standard
However this interoperability starts to fall apart when languages add typing
 extensions that aren't supported by the CLI.
 Units of measure in F#, for example, are erased at compile time; therefore
 other modules which consume an F# module where units of measure were used
 cannot see, and be type-checked according to, the units.
 This loss of typing information is not ideal, as it reduces interoperability,
 and so prompts us to consider adding value dependence as a CLI feature
 and not just an extension to a current CLI language such as C# or F#.
 If units could be written in terms of dependent types then we can 
\emph on
fix
\emph default
 them, else at least our extension will not suffer the same problem of interoper
ability.
 
\end_layout

\begin_layout Standard
Moreover any new features added to the CLI should be backwards compatible
 and efficient, we need to keep in mind the size of the new types and their
 instances, the size of the byte code and the speed to process it and the
 speed and size of the JITed code.
\end_layout

\begin_layout Section
Project
\end_layout

\begin_layout Standard
This project will investigate value dependent types in the CLI.
 It will be split into 3 parts.
 
\end_layout

\begin_layout Enumerate
To investigate the use and benefits of value dependent typing.
\end_layout

\begin_layout Enumerate
To show how value dependent types could be added to the CLI, preferably
 in a clean and backwards compatible way.
\end_layout

\begin_layout Enumerate
If part 2 is successful to implement value dependent typing in Mono.
 
\end_layout

\begin_layout Enumerate
If part 2 is unsuccessful then an through explanation of why it can't be
 done should be written.
\end_layout

\begin_layout Standard
The rest of this report looks more in depth at the CLI and then covers various
 type system enhancements related to value dependence and value dependence
 itself.
 It finishes with an plan for the rest of the project and it's evaluation.
\end_layout

\begin_layout Chapter
Background
\end_layout

\begin_layout Section
The CLI
\end_layout

\begin_layout Subsection
Common intermediate language
\end_layout

\begin_layout Standard
To allow the reader to more easily follow later discussions we will first
 briefly go over the CLI and CIL.
 For those more familiar with Java; the CLI can be compared to the JVM,
 and CIL to Java Bytecode.
 The CLI runs Common Intermediate Language (CIL) byte code.
 CIL is a type rich, stack based assembly language.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Hello world
\end_layout

\end_inset

.assembly Hello {} 
\end_layout

\begin_layout Plain Layout

.assembly extern mscorlib {} 
\end_layout

\begin_layout Plain Layout

.method static void Main() 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	.entrypoint     
\end_layout

\begin_layout Plain Layout

	.maxstack 1     
\end_layout

\begin_layout Plain Layout

	ldstr "Hello, world!"     
\end_layout

\begin_layout Plain Layout

	call void [mscorlib]System.Console::WriteLine(string)     
\end_layout

\begin_layout Plain Layout

	ret 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
CIL supports many features not common for low level assembly code, as well
 as basic operations such as add, jump, load, store.
 Operations such as field access, method call, object creation, casting
 etc all have dedicated CIL instructions.
\end_layout

\begin_layout Standard
While CIL is targeted by a variety of languages Visual Basic and C# match
 it's semantics most closely so we will use C# code instead of raw CIL when
 possible in examples.
 Some CLI/C# features are uncommon in other languages so we we'll briefly
 go over them.
 These features 
\end_layout

\begin_layout Subsection
Value and Reference types
\end_layout

\begin_layout Standard
The CLI (and C#) differentiates between value types (structs) and reference
 types (classes).
 Value types are allocated inline, either on the stack or as part of a containin
g types allocation.
 Reference types are allocated on the heap and referred to by a pointer
 (called a reference), these are tracked by the garbage collector.
 To compare this to C++, 
\family typewriter
Foo
\family default
 is a value type, while 
\family typewriter
Foo*
\family default
 is a reference type, the semantics are similar.
\end_layout

\begin_layout Subsection
Literal and initonly
\begin_inset CommandInset label
LatexCommand label
name "sub:Literal-and-initonly"

\end_inset


\end_layout

\begin_layout Standard
Fields in the CLI can be marked as 
\family typewriter
initonly
\family default
, and if they are static fields, 
\family typewriter
literal
\family default
.
\end_layout

\begin_layout Standard
A 
\family typewriter
static literal
\family default
 field has no space allocated for it in the metadata, instead any reference
 to that field must have the literal value copied into the use site, as
 such literal fields must be a primitive type (int, float, string etc).
 In C# the keyword 
\family typewriter
const
\family default
 is used instead of 
\family typewriter
literal
\family default
.
\end_layout

\begin_layout Standard
An 
\family typewriter
initonly
\family default
 field can only be written to by a constructor method (or if static by the
 type initializer method).
 Other methods can only load from the field.
 In C# the keyword 
\family typewriter
readonly
\family default
 is used instead of 
\family typewriter
initonly
\family default
.
 The property initonly is not transitive, for example the following C# shows
 a readonly Pair field being mutated, this is valid code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

class Pair
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public int A;
\end_layout

\begin_layout Plain Layout

	public int B;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Pair(int a, int b)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		A = a;
\end_layout

\begin_layout Plain Layout

		B = b;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Program
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public readonly Pair MyPair;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Program()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		MyPair = new Pair(1, 2);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	static Main()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var program = new Program();
\end_layout

\begin_layout Plain Layout

		//program.MyPair = new Pair(3, 4); not valid
\end_layout

\begin_layout Plain Layout

		program.MyPair.A = 3; // valid
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a very weak concept of immutability, and when adding user defined
 types to value dependence could present problems.
\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Standard
As pointed out above the CIL has instructions for field access but it also
 has first class support for properties.
 In the CIL code these look similar to method calls but in C# they look
 like field access.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

class Square {
\end_layout

\begin_layout Plain Layout

	public int Length;
\end_layout

\begin_layout Plain Layout

	public int Area { get { return Length * Length; } }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	static void Main() {
\end_layout

\begin_layout Plain Layout

		Square sq = new Square();
\end_layout

\begin_layout Plain Layout

		sq.Length = 4;
\end_layout

\begin_layout Plain Layout

		Console.WriteLine(sq.Area); // outputs 16
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The corresponding CIL follows, note the method call for 
\family typewriter
get_Area
\family default
 at 
\family typewriter
L_000f
\family default
 in 
\family typewriter
Main
\family default
.
 While the property getter is just a method it is marked up specially in
 the 
\family typewriter
.property
\family default
 clause so that other tools can treat it as such.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

.class private auto ansi beforefieldinit Square     
\end_layout

\begin_layout Plain Layout

extends [mscorlib]System.Object 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	.method private hidebysig static void Main() cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.entrypoint
\end_layout

\begin_layout Plain Layout

		.maxstack 2
\end_layout

\begin_layout Plain Layout

		.locals init ([0] class Square sq)
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

		newobj instance void Square::.ctor()         
\end_layout

\begin_layout Plain Layout

		stloc.0          
\end_layout

\begin_layout Plain Layout

		ldloc.0          
\end_layout

\begin_layout Plain Layout

		ldc.i4.4          
\end_layout

\begin_layout Plain Layout

		stfld int32 Square::Length         
\end_layout

\begin_layout Plain Layout

		ldloc.0          
\end_layout

\begin_layout Plain Layout

		callvirt instance int32 Square::get_Area()         
\end_layout

\begin_layout Plain Layout

		call void [mscorlib]System.Console::WriteLine(int32)         
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	.property instance int32 Area     
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.get instance int32 Square::get_Area()
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	.field public int32 Length 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig specialname instance int32 get_Area() cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld int32 Square::Length
\end_layout

\begin_layout Plain Layout

		ldarg.0 
\end_layout

\begin_layout Plain Layout

		ldfld int32 Square::Length
\end_layout

\begin_layout Plain Layout

		mul
\end_layout

\begin_layout Plain Layout

		ret  
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Properties support get and set methods (both optional), which do not have
 to have the same visibility (it's valid to have a public get and private
 set).
 Properties can also have parameters which turns them into indexers.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

class StringIntMap {
\end_layout

\begin_layout Plain Layout

	public int this[string key] { 
\end_layout

\begin_layout Plain Layout

		get { ...; } set { ...; } // assuming a sensible implementation
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Main() {
\end_layout

\begin_layout Plain Layout

	StringIntMap map = new StringIntMap();
\end_layout

\begin_layout Plain Layout

	map["test"] = 1;
\end_layout

\begin_layout Plain Layout

	Console.WriteLine(map["test"]); // outputs 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generics
\end_layout

\begin_layout Standard
The CLI supports parametric polymorphic types via generics types.
 Generic types are parametrized on other types (value dependence would allow
 types to also be parametrized on values).
 The MSR White paper 
\begin_inset CommandInset citation
LatexCommand cite
key "ext-vox"

\end_inset

 describes some initial design considerations to do parametric polymorphism
 in COM+ (the original name for what became the CLI and .NET).
 While the final design and implementation that shipped with .NET differs
 slightly from the design presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "ext-vox"

\end_inset

, the paper does give an insight into what we need to be thinking about
 while designing value parametrics.
 It's worth taking some time to look at how generics ended up being specified
 in ECMA-335
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

 and implemented in Mono (due to copyright reasons we can't look at Microsoft’s
 open source CLR code).
 
\end_layout

\begin_layout Standard
Generics are defined in section II.9 of 
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

.
 A type in the CLI can have a fixed generic arity (that is generics are
 not variadic), the parameters are unnamed and are accessed by index (either
 !0 or for type parameters and !!0 for method parameters).
 Each type parameter may be constrained by a number of properties, including
 constraints on being a value or reference type, having a defined base class
 or interface or being default constructable.
 Type parameters can be value or reference types; this is a marked difference
 from the suggestion in 
\begin_inset CommandInset citation
LatexCommand cite
key "ext-vox"

\end_inset

 which suggested that value types should not be allowed due to having to
 re-JIT the types code for each value type.
\end_layout

\begin_layout Standard
Generics allow the CLI to represent types such as 
\family typewriter
List<T>
\family default
 while retaining run time information such that the run time type of 
\family typewriter
List<object>
\family default
 is different to 
\family typewriter
List<int>
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
In contrast theses types would be equivalent in the JVM.
\end_layout

\end_inset

.
 
\family typewriter
List<int>
\family default
 is also special in that 
\family typewriter
int
\family default
 is a value type and yet the run time can use a 
\family typewriter
List<int>
\family default
without causing excessive boxing of values.
\end_layout

\begin_layout Standard
If we look at the definition of 
\family typewriter
List<T>
\family default
 in Microsoft’s distribution of .NET 4.0 we can see how the generic parameter
 is declared and used.
\begin_inset listings
lstparams "numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

.class public auto ansi serializable beforefieldinit List`1<T>
\end_layout

\begin_layout Plain Layout

extends [mscorlib]System.Object 
\end_layout

\begin_layout Plain Layout

implements System.Collections.Generic.IList`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.Generic.ICollection`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.Generic.IEnumerable`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.IList, 
\end_layout

\begin_layout Plain Layout

	System.Collections.ICollection, 
\end_layout

\begin_layout Plain Layout

	System.Collections.IEnumerable
\end_layout

\begin_layout Plain Layout

{ ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The declaration 
\family typewriter
.class public auto ansi serializable beforefieldinit List`1<T>
\family default
 declares a new class type with one generic parameter 
\family typewriter
T
\family default
, which has no constraints.
 The 
\family typewriter
implements
\family default
 clause lists interfaces implemented by 
\family typewriter
List`1<T>
\family default
, the first three of these interfaces are themselves generic.
 On line 3 the 
\family typewriter
System.Collections.Generic.IList`1
\family default
 syntax indicates that we mean the generic 
\family typewriter
IList
\family default
 with one parameter 
\family typewriter
`1
\family default
, while <!0> refers to the first generic class parameter 
\family typewriter
T
\family default
, and passes that as the type argument to 
\family typewriter
IList
\family default
.
\end_layout

\begin_layout Standard
Generic parameters can also be constrained, a run length compressed list
 for example would require that the type it stored had an equality operator.
 The 
\family typewriter
IEquatable<T>
\family default
 interface defines a method 
\family typewriter
bool Equal(T value)
\family default
, so if a type 
\family typewriter
T
\family default
 inherits from 
\family typewriter
IEquatable<T>
\family default
 then it can be compared equal to other values of its type.
 Adding the constraint that the first generic parameters has this property
 is shown here.
 Note the 
\family typewriter
(IEquatable`1<!0>)
\family default
 before the 
\family typewriter
T
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

.class public auto ansi sealed beforefieldinit
\end_layout

\begin_layout Plain Layout

	CompressedList`1<(IEquatable`1<!0>) T> 
\end_layout

\begin_layout Plain Layout

extends [mscorlib]System.Object
\end_layout

\begin_layout Plain Layout

implements System.Collections.Generic.IEnumerable`1<!0>, 
\end_layout

\begin_layout Plain Layout

	System.Collections.IEnumerable
\end_layout

\begin_layout Plain Layout

{ ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sometimes it is necessary to distinguish between instantiated and non-instantiat
ed generic types.
 Common terminology for this, as used in ECMA-335, is close and open generic
 types.
 A closed generic type is one that has no unbound type parameters, conversly
 an open generic type is a generic type that has at least one unbound type
 paramter.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Open and closed type in C# syntax
\end_layout

\end_inset

Dictionary<TKey, TValue> a; // open
\end_layout

\begin_layout Plain Layout

Dictionary<TKey, int> b; // open
\end_layout

\begin_layout Plain Layout

Dictionary<string, int> c; // close
\end_layout

\end_inset


\end_layout

\begin_layout Section
C++ templates
\begin_inset CommandInset label
LatexCommand label
name "sec:Cpp-templates"

\end_inset


\end_layout

\begin_layout Standard
C++ templates allow functions and types to be parametrized by types or values.
 Templates are a turning complete language by themselves making them very
 general, however most implementations of templates simply perform substitution
 at compile time leading to a large amount of generated code that then has
 to be reduced by looking for similarities (in contrast to CLR and Mono
 generics that duplicate very little code), and with large use cases substantial
 slowdowns to compilation time.
\end_layout

\begin_layout Standard
Many libraries including the standard library make use of templates, particulari
ty the parametrization on types.
 Parametrization on values is less used but it's similarities to value dependenc
e make it worth looking at, to this end we will look at a few examples from
 the standard library, Boost
\begin_inset CommandInset citation
LatexCommand cite
key "boost"

\end_inset

 and CML
\begin_inset CommandInset citation
LatexCommand cite
key "cmldev"

\end_inset

.
 
\end_layout

\begin_layout Standard
The standard C++ library uses value templates in a few places including
 
\family typewriter
std::ratio
\family default
 and the random number generation library.
 
\family typewriter
std::ratio
\family default
 is a compile time rational number added in C++11, it reduces the numerator
 and denominator to lowest terms at compile time.
 The random number generator uses template values to set generator parameters
 such as the constants 
\family typewriter
a
\family default
, 
\family typewriter
c
\family default
 and 
\family typewriter
m
\family default
 to be used in 
\family typewriter
std::linear_congruential_engine
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

template<
\end_layout

\begin_layout Plain Layout

	class UIntType, 
\end_layout

\begin_layout Plain Layout

	UIntType a, 
\end_layout

\begin_layout Plain Layout

	UIntType c, 
\end_layout

\begin_layout Plain Layout

	UIntType m 
\end_layout

\begin_layout Plain Layout

> class linear_congruential_engine;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The open source Boost
\begin_inset CommandInset citation
LatexCommand cite
key "boost"

\end_inset

 libraries make use of value templates much more, using them in obvious
 ways in the Array library, which is for safer arrays using a new class
 
\family typewriter
Array<typename T, int N>
\family default
, but also scattered throughout the other libraries.
 For example in 
\family typewriter
Spirit::Qi
\family default
, a parser combinator library, the type 
\family typewriter
unit_parser
\family default
 is templated on the type name of the integer type to return but also on
 the values of the radix and minimum and maximum digits to parse.
 
\end_layout

\begin_layout Standard
Finally CML
\begin_inset CommandInset citation
LatexCommand cite
key "cmldev"

\end_inset

 uses value templates to define the sizes of vectors and matrices, this
 is similar to our motivating example in C#.
 Vector and matrix are templated on two types 
\family typewriter
ElementT
\family default
 and 
\family typewriter
StorageT
\family default
.
 
\family typewriter
ElementT
\family default
 is the element type, float, double, int or another type that supports the
 same operations.
 
\family typewriter
StorageT
\family default
 is a type that provides access to the elements, either by pointing to an
 external data source or storing the data itself.
 Two of the built in storage types (fixed and external) are templated on
 the value of how many elements they store/point to.
 When using these statically sized storage types you get extra static type
 safety that you're not mixing vector sizes in operations.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

cml::vector<float, fixed<3>> a(1,0,0);
\end_layout

\begin_layout Plain Layout

cml::vector<float, fixed<2>> b = a; // compile error
\end_layout

\begin_layout Plain Layout

cml::matrix<float, fixed<2,2>> i(1, 2, 3, 4);
\end_layout

\begin_layout Plain Layout

cml::matrix<float, fixed<3,3>> j = i; // compile error
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's worth noting that although this example looks like the constructors
 match the value passed to fixed they are actually pre declared constructors
 for all normal sizes, using the wrong constructor will either leave some
 elements uninitialized or not use some of the values passed in.
 Real variadic parameters that matched the dimension of the vector/matrix
 would be better, and with the new features of C++11 might be possible.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Path dependance?
\end_layout

\begin_layout Plain Layout
Printf example.
\end_layout

\end_inset


\end_layout

\begin_layout Section
F# units of measure
\begin_inset CommandInset label
LatexCommand label
name "sec:Fsharp-units"

\end_inset


\end_layout

\begin_layout Standard
F# has the ability to markup number values with units of measure that allow
 checking of units at compile time.
 This extra checking can prevent mistakes such as that which brought down
 the Mars Climate Orbiter in 1999.
 The Orbiter crashed because of a mismatch between Imperial and Metric units
 in force calculation.
 A very expensive mistake as the mission cost $327.6 million
\begin_inset CommandInset citation
LatexCommand cite
key "mars"

\end_inset

.
 
\end_layout

\begin_layout Standard
Units of measure are declared as opaque types marked up with the 
\family typewriter
Measure
\family default
 attribute.
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=ML"
inline false
status open

\begin_layout Plain Layout

[<Measure>] type meter
\end_layout

\end_inset

They can also be declared as equal to other units, for example milliliters
 as cubic centimeters.
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=ML"
inline false
status open

\begin_layout Plain Layout

[<Measure>] type ml = cm^3
\end_layout

\end_inset

The normal unit operators such as multiplication, division and powers are
 usable and can be worked out by the type inference engine.
 For example in the following, code type inference correctly identifies
 
\family typewriter
distance
\family default
 as type 
\family typewriter
float<meter>
\family default
.
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=ML"
inline false
status open

\begin_layout Plain Layout

let speed = 55.0<meter/second>
\end_layout

\begin_layout Plain Layout

let time = 3.5<second>
\end_layout

\begin_layout Plain Layout

let distance = speed * time;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

speed    : float<meter/second>
\end_layout

\begin_layout Plain Layout

time     : float<second>
\end_layout

\begin_layout Plain Layout

distance : float<meter>
\end_layout

\end_inset

The compiler will normalize units of measure to a standard form, from the
 MSDN documentation
\begin_inset CommandInset citation
LatexCommand cite
key "fsharp-units-of-measure"

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Unit formulas that mean the same thing can be written in various equivalent
 ways.
 Therefore, the compiler converts unit formulas into a consistent form,
 which converts negative powers to reciprocals, groups units into a single
 numerator and a denominator, and alphabetizes the units in the numerator
 and denominator.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Units of measure are a common praise of F# and provided a valuable case
 study for us to use in our type system extension.
 
\end_layout

\begin_layout Standard
F# units of measure are checked at compile time, implemented as a sort separate
 from the standard types.
 However all units units information is erased from the run time.
 Therefore values cast to 
\family typewriter
Object
\family default
 cannot be recast to a measured type safely at run time, but also these
 units cannot be exposed as part of a public interface to be consumed by
 other CLI languages such as C# or VB.
 
\end_layout

\begin_layout Standard
While they are implemented as a separate sort they behave somewhat like
 values of a standard type (with operations for multiplication and division).
 A system that allowed them to be values of a Measure type (rather than
 a separate sort) while retaining the current features (including inference)
 would be impressive and something our system should strive for.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Example Unit type
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

public sealed class Unit 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	public static Unit One     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		get         
\end_layout

\begin_layout Plain Layout

		{             
\end_layout

\begin_layout Plain Layout

			return new Unit(new List<Tuple<string, int>>());         
\end_layout

\begin_layout Plain Layout

		}     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	private readonly List<Tuple<string, int>> Units;
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	private Unit(List<Tuple<string, int>> units)     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		Units = units;     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	public Unit(string unit)     
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Units = new List<Tuple<string, int>>();
\end_layout

\begin_layout Plain Layout

		Units.Add(Tuple.Create(unit, 1));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	public static Unit operator *(Unit a, Unit b)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new Unit(Product(a.Units, b.Units));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	public static Unit operator /(Unit a, Unit b)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new Unit(Product(a.Units, Reciprocal(b.Units)));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	public static Unit operator ^(Unit a, int power)
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		if (power == 0)
\end_layout

\begin_layout Plain Layout

			return One;
\end_layout

\begin_layout Plain Layout

		return new Unit(Power(a.Units, power));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	private static List<Tuple<string, int>> Normalize(
\end_layout

\begin_layout Plain Layout

		List<Tuple<string, int>> units)     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		var groups = units.GroupBy(tuple => tuple.Item1);         
\end_layout

\begin_layout Plain Layout

		var sums = groups.Select(group => 
\end_layout

\begin_layout Plain Layout

			Tuple.Create(group.Key, group.Sum(unit => unit.Item2)));         
\end_layout

\begin_layout Plain Layout

		var filter = sums.Where(unit => unit.Item2 != 0);        
\end_layout

\begin_layout Plain Layout

		var sorted = filter.OrderBy(unit => unit.Item1); 
\end_layout

\begin_layout Plain Layout

		return sorted.ToList(); 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	private static List<Tuple<string, int>> Product(
\end_layout

\begin_layout Plain Layout

		List<Tuple<string, int>> a, List<Tuple<string, int>> b)     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		return Normalize(a.Concat(b).ToList());     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	private static List<Tuple<string, int>> Power(
\end_layout

\begin_layout Plain Layout

		List<Tuple<string, int>> a, int power)     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		return a.Select(unit => 
\end_layout

\begin_layout Plain Layout

			Tuple.Create(unit.Item1, unit.Item2 * power)).ToList();     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	private static List<Tuple<string, int>> Reciprocal(
\end_layout

\begin_layout Plain Layout

		List<Tuple<string, int>> units)     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		return units.Select(unit => 
\end_layout

\begin_layout Plain Layout

			Tuple.Create(unit.Item1, -unit.Item2)).ToList();  
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	public override bool Equals(object obj)     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		if (obj is Unit)         
\end_layout

\begin_layout Plain Layout

		{             
\end_layout

\begin_layout Plain Layout

			var other = obj as Unit;
\end_layout

\begin_layout Plain Layout

			            
\end_layout

\begin_layout Plain Layout

			return                  
\end_layout

\begin_layout Plain Layout

				Units.Count == other.Units.Count &&                  
\end_layout

\begin_layout Plain Layout

				Units.Zip(other.Units, (a, b) => 
\end_layout

\begin_layout Plain Layout

					a.Item1 == b.Item1 && a.Item2 == b.Item2).All(b => b);         
\end_layout

\begin_layout Plain Layout

		}         
\end_layout

\begin_layout Plain Layout

		return false;     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	    
\end_layout

\begin_layout Plain Layout

	public override string ToString()     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		return string.Join(" ", Units.Select(unit => 
\end_layout

\begin_layout Plain Layout

			string.Format("{0}^{1}", unit.Item1, unit.Item2)));     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

public static void Example()     
\end_layout

\begin_layout Plain Layout

{         
\end_layout

\begin_layout Plain Layout

	Unit meters = new Unit("m");         
\end_layout

\begin_layout Plain Layout

	Unit seconds = new Unit("s");        
\end_layout

\begin_layout Plain Layout

	Unit metersPerSecond = meters / seconds;     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Path dependent types
\begin_inset CommandInset label
LatexCommand label
name "sec:Path-dependent-types"

\end_inset


\end_layout

\begin_layout Standard
Path dependent types like those found in Scala are similar to value dependent
 types in that they depend on the value of the object that created them,
 but they are not as general.
 An example of path dependence in Scala is the following Board and Coordinate
 example
\begin_inset CommandInset citation
LatexCommand cite
key "stack-2693067"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=scala,tabsize=4"
inline false
status open

\begin_layout Plain Layout

case class Board(length: Int, height: Int) 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

	case class Coordinate(x: Int, y: Int) 
\end_layout

\begin_layout Plain Layout

	{      
\end_layout

\begin_layout Plain Layout

		require(0 <= x && x < length && 0 <= y && y < height)    
\end_layout

\begin_layout Plain Layout

	}   
\end_layout

\begin_layout Plain Layout

	val occupied = scala.collection.mutable.Set[Coordinate]() 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val b1 = Board(20, 20) 
\end_layout

\begin_layout Plain Layout

val b2 = Board(30, 30)
\end_layout

\begin_layout Plain Layout

var b3 = b1
\end_layout

\begin_layout Plain Layout

val c1 = b1.Coordinate(15, 15) 
\end_layout

\begin_layout Plain Layout

val c2 = b2.Coordinate(25, 25) 
\end_layout

\begin_layout Plain Layout

b1.occupied += c1 
\end_layout

\begin_layout Plain Layout

b2.occupied += c2
\end_layout

\begin_layout Plain Layout

b3.occupied += c1
\end_layout

\begin_layout Plain Layout

// Next line doesn't compile 
\end_layout

\begin_layout Plain Layout

b1.occupied += c2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here the type of 
\family typewriter
c1
\family default
 and 
\family typewriter
c2
\family default
 depend on the values 
\family typewriter
b1
\family default
 and 
\family typewriter
b2
\family default
.
 Not that it is in fact the values not these specific identifiers that are
 the dependence, as shown on line 17.
 Path dependence in the type system does not allow line 19, which is stricter
 than just inner classes in Java.
 
\end_layout

\begin_layout Standard
Path dependence is an extension of the fact that in Scala and Java inner
 classes are created via an instance of the outer class and maintain a reference
 to their creator.
 I call the creation via an instance of the outer class an instance inner
 types, as opposed to static inner types that do not require an instance
 of the outer class.
 The CLI does not support path dependent types or instance inner types,
 the only difference between inner and outer class in the CLI is viability
 (that is an inner class can be made private and thus only be accessed by
 the outer class).
 While it's possible to require a reference to the outer class as part of
 the inner class's constructor it is not a requirement.
 While instance created inner classes and then path dependence could be
 added at the language level this leads to the risk that Scala ran into
 where the virtual machine reflection system no longer resembled the language
 type system, thus pushing for the implementation of a whole new reflection
 system to be built.
 
\end_layout

\begin_layout Standard
Therefore if we are to investigate the addition of adding path dependent
 types we also need to add instance inner types to the CLI.
 Alternatively we could try to design value dependence such that the following
 was possible.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

class Board
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int length, height;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Board(int length, int height)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.length = length;
\end_layout

\begin_layout Plain Layout

		this.height = height;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	class Coordianate<Board b>
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		public Coordinate(int x, int y)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			require(0 <= x && x < b.length && 0 <= y && y < b.height)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Set<Coordianate<this>> occupied = new Set<Coordinate<this>>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Allowing the value parameter to be any type is much more general than path
 dependence, In this case 
\family typewriter
Coordinate
\family default
 would not even need to be an inner class of 
\family typewriter
Board
\family default
.
 However  this is a very ambitious addition and if it's even possible is
 uncertain.
\end_layout

\begin_layout Section
Virtual types
\begin_inset CommandInset label
LatexCommand label
name "sec:Virtual-types"

\end_inset


\end_layout

\begin_layout Standard
Virtual types are also found in Scala, they allow a subclass to override
 a type variable in the super class.
 In the following example the type 
\family typewriter
T
\family default
 declared in class 
\family typewriter
A
\family default
 is made more specific in the subclass 
\family typewriter
B
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

class A
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	type T
\end_layout

\begin_layout Plain Layout

	abstract T foo();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class B 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	override type T = String
\end_layout

\begin_layout Plain Layout

	override T foo() { return "string"; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While virtual types can be useful everything they accomplish can also be
 done with generics, albeit with sometime much more syntax.
 
\begin_inset CommandInset citation
LatexCommand cite
key "staticvts"

\end_inset

 shows how the same program can be expressed with virtual types or parametrized
 types.
 While one way is often more elegant than the other you gain little in supportin
g both.
 As parametrized types are already supported by the CLI virtual types are
 not hugely interesting.
\end_layout

\begin_layout Section
First class types
\end_layout

\begin_layout Standard
Cayenne
\begin_inset CommandInset citation
LatexCommand cite
key "cayenne"

\end_inset

 is a language with support for dependent types and first class types (i.e.
 types can be be used like values).
 As Cayenne is a functional language inspired by Haskell, it's unlikely
 we can lift ideas straight from it to be used in the CLI, however it provides
 an example of a very general dependent types system.
 Two core features of Cayenne are dependent functions and dependent records.
 Dependent functions allow a function return type to depend on the value
 of the parameter, as shown in the following example from 
\begin_inset CommandInset citation
LatexCommand cite
key "cayenne"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=Haskell"
inline false
status open

\begin_layout Plain Layout

printfType :: String -> #
\end_layout

\begin_layout Plain Layout

PrintfType "" = String
\end_layout

\begin_layout Plain Layout

PrintfType ('%':'d':cs) = Int    -> PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType ('%':'s':cs) = Stirng -> PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType ('%':_:cs)   =           PrintfType cs
\end_layout

\begin_layout Plain Layout

PrintfType (_:cs)       =           PrintfType cs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

printf :: (fmt::String) -> PrintfType fmt
\end_layout

\begin_layout Plain Layout

printf fmt = pr fmt ""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pr :: (fmt::String) -> String -> PrintfType fmt
\end_layout

\begin_layout Plain Layout

pr "" res = res
\end_layout

\begin_layout Plain Layout

pr ('%':'d':cs) res = 
\backslash
(i::Int) -> pr cs (res ++ show i)
\end_layout

\begin_layout Plain Layout

pr ('%':'s':cs) res = 
\backslash
(s::String) -> pr cs (res ++ s)
\end_layout

\begin_layout Plain Layout

pr ('%':c:cs) res   = pr cs (res ++ [c])
\end_layout

\begin_layout Plain Layout

pr (c:cs) res       = pr css (res ++ [c])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example the type of 
\family typewriter
printf
\family default
 depends on the value of the parameter fmt.
 This also shows how types and values are treated equally in Cayenne.
 The type 
\family typewriter
#
\family default
 is the type of all types (normal notation is 
\family typewriter
*
\family default
 but 
\family typewriter
#
\family default
 was chosen to avoid clashes with the infix operator 
\family typewriter
*
\family default
).
 
\end_layout

\begin_layout Section
Generalized algebraic data types
\begin_inset CommandInset label
LatexCommand label
name "sec:GADTs"

\end_inset


\end_layout

\begin_layout Standard
Generalized algebraic data types (GADTs) are predominately a feature of
 functional languages.
 They are an extension to algebraic data types.
 They allow more expression in data type constructors, in particular they
 allow pattern matching and more general recursion in a data constructor.
 The common example is a type for terms in a small language; with GADTs
 it's possible to express constraints on the expression trees that are not
 expresable in normal ADTs.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
GADT
\end_layout

\end_inset

data Exp t where
\end_layout

\begin_layout Plain Layout

	Lit :: Int -> Exp Int
\end_layout

\begin_layout Plain Layout

	Plus :: Exp Int -> Exp Int -> Exp Int
\end_layout

\begin_layout Plain Layout

	Equals :: Exp Int -> Exp Int -> Exp Bool
\end_layout

\begin_layout Plain Layout

	Cond :: Exp Bool -> Exp a -> Exp a -> Exp a
\end_layout

\end_inset

This data type will only allow correct instantations of 
\family typewriter
Exp
\family default
 as paramters.
 The constraint that 
\family typewriter
Plus
\family default
 takes two 
\family typewriter
Int
\family default
 expressions and returns a new Int expression is expressed.
 As is the constraint that 
\family typewriter
Cond
\family default
 must take a 
\family typewriter
Bool
\family default
 expression and two other expression of the same type returning an expression
 of that type.
 Without GADTs these constraints cannot be expressed, the following shows
 the same type as an ADT.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=Haskell,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ADT
\end_layout

\end_inset

data Exp 
\end_layout

\begin_layout Plain Layout

	= Lit Int
\end_layout

\begin_layout Plain Layout

	| Plus Exp Exp 
\end_layout

\begin_layout Plain Layout

	| Equals Exp Exp
\end_layout

\begin_layout Plain Layout

	| Cond Exp Exp Exp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first expression passed to 
\family typewriter
Cond
\family default
 must evaluate to a boolean result (from 
\family typewriter
Equals
\family default
), but the type system cannot express that.
\end_layout

\begin_layout Standard
There are more examples that can be statically checked with GADTs such as
 lists that have their size as part of their type and statically typed printf
 functions.
\end_layout

\begin_layout Standard
The use of GADTs in object orientated languages is less common than in functiona
l languages (Haskell has supported GADTs for over 10 years) but 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 shows how GADT programs can be expressed in C# with some modifications
 to the language.
 The two modifications proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 are an extension of generic constraints and an extension of the switch
 statement.
 
\end_layout

\begin_layout Standard
The extension to generic constraints would allow equality constraints on
 generic types, section 3.1 (Equational constraints for C#) of 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 describes this extension.
 This would allow a generic type to be declared equal to another type, this
 would be checked statically at compile time.
 
\end_layout

\begin_layout Standard
We'll use a different example from the expressions code above, as the expression
 type is much larger expressed in C#.
 Instead we'll look at list flatten methods.
 A list flatten method could check that the list was a list of lists by
 the addition of the 
\family typewriter
where T=List<U>
\family default
 clause.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
C# GADT
\begin_inset CommandInset label
LatexCommand label
name "lis:csharp gadt"

\end_inset


\end_layout

\end_inset

public abstract class List<T> {
\end_layout

\begin_layout Plain Layout

	public abstract List<T> Append(List<T> list);
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() where T=List<U>;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Nil<T> : List<T> {
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return new Nil<U>;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Cons<T> : List<T> {	
\end_layout

\begin_layout Plain Layout

	T head; List<T> tail;
\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() {
\end_layout

\begin_layout Plain Layout

		return this.head.Append(this.tail.Flatten());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calling 
\family typewriter
Flatten
\family default
 on a 
\family typewriter
List<T>
\family default
 would statically check that 
\family typewriter
T=List<U>
\family default
 where 
\family typewriter
U
\family default
 is any type.
 Thus in the method body of flatten we can assume that the type of 
\family typewriter
head
\family default
 is 
\family typewriter
List<U>
\family default
 which has an 
\family typewriter
Append
\family default
 method.
 While 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 suggests this addition of type equality constraints as a C# extension;
 generic constraints are currently encoded at the CLI level and so we could
 add this as a CLI extension.
 Adding type equality constraints at the CLI level would allow it to be
 added to C# and other languages more easily.
 
\end_layout

\begin_layout Standard
The second proposal is an extension to the switch statement to allow switching
 on types, binding type 
\family typewriter
variables
\family default
 in switch case clauses and matching multiple expressions.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

switch (e1, e2)
\end_layout

\begin_layout Plain Layout

	case (Lit x, Lit y):
\end_layout

\begin_layout Plain Layout

		return x.value == y.value;
\end_layout

\begin_layout Plain Layout

	case (Tuple<A,B> x, Tuple<C,D> y):
\end_layout

\begin_layout Plain Layout

		return Eq(x.fst, y.fst) && Eq(x.snd, y.snd);
\end_layout

\begin_layout Plain Layout

	default:
\end_layout

\begin_layout Plain Layout

		returna false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While standard switch statements are a language feature (at the CLI level
 they are encoded through a sequence of if statements) the authors point
 out that support at the CLI level for a match-and-bind primitive would
 be useful (see the end of section 3.4 in 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

) as their switch extension is currently difficult to translate to CIL code,
 having to rely on run time reflection and generic methods to bind correctly.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Add printf example
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
Having looked at all these type systems we can see that some systems are
 more powerfull, while other are equal in power but differ in expresivity.
\end_layout

\begin_layout Standard

\series bold
C++ templates
\series default
 being Turing complete are the most powerful system we've looked at, but
 that comes with it's downsides.
 Efficiently compiling templates such that the final code is small and fast
 is difficult, they also make the language unsound as a template can recurse
 forever (although most compilers have hard limits to this).
\end_layout

\begin_layout Standard
The next most general is 
\series bold
value dependence
\series default
.
 Value dependence allowed types to be constructed based on values.
 While this is powerful allowing arbitrary values as parameters is undecidable,
 as it amounts to determining whether two different programs produce the
 same result.
 In chapter 30.5 of 
\begin_inset CommandInset citation
LatexCommand cite
key "tapl"

\end_inset

 is a warning about dependent types:
\end_layout

\begin_layout Quotation
Unfortunately, the power of dependent types is a two-edged sword.
 Blurring the distinction between checking types and carrying out proofs
 of arbitrary theorems does not magically make theorem proving simple -
 on the contrary, it makes type checking computationally intractable! Mathematic
ians working with mechanical proof assistants do not just type in a theorem,
 press a button, and sit back to wait for a Yes or No: they spend significant
 effort writing proof scripts and tactics to guide the tool in constructing
 and verifying a proof.
 If we carry the idea of correctness by construction to its limits, programmers
 should expect to expend similar amounts of effort annotating programs with
 hints and explanations to guide the type checker.
 For certain critical programming tasks, this degree of effort may be justified,
 but for day-to-day programming it is almost certainly too costly.
\end_layout

\begin_layout Standard
The CLI as a mainstream day-to-day infrastructure would certainly not benefit
 from an extension that required significant expenditure of programmer time.
 As such, we do not actually want to make our system too powerful, we want
 to find a balance between opening up opportunities for optimization and
 expressivity and the cost of annotation and understanding.
\end_layout

\begin_layout Standard

\series bold
GADTs
\series default
 come in next.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:GADTs"

\end_inset

 explored how GADTs can be expressed in C# with some modifications.
 As generic constraints are already stored in the metadata, taking these
 ideas and expanding them to cover type equality should be simple.
 
\end_layout

\begin_layout Standard
We've seen how 
\series bold
virtual types
\series default
 are equivalent to generics.
 As the CLI already supports generics further investigation of virtual types
 seems unnecessary.
 Finally, path dependence is a simpler case of value dependence as are F#
 units of measure.
 
\end_layout

\begin_layout Standard
So while full value dependence may be too much, GADTs aren't enough leading
 us to think about an extension somewhere in between the two.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{c}
Templates\\
Value\; dependence\\
Our\; extension?\\
GADTs\sim Generics+Type\; equality\; constraints\\
Virtual\; types\sim Generics
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
The following table shows some of the differances and similarites between
 these systems.
 The Type safe printf column indicates if the system can express a printf
 like function in a type safe way.
 The type sized lists column indicates if the system can express lists that
 carry their size as part of their type.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="7">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="12line%">
<column alignment="center" valignment="top" width="12line%">
<column alignment="center" valignment="top" width="12line%">
<column alignment="center" valignment="top" width="12line%">
<column alignment="center" valignment="top" width="12line%">
<column alignment="center" valignment="top" width="12line%">
<column alignment="center" valignment="top" width="12line%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Turing complete
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type safe printf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type sized lists
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decidable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Units of measure
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Path dependence
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Templates
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?
\begin_inset Foot
status open

\begin_layout Plain Layout
Being Turing complete it feels this should be yes, however we can't find
 any material to suggest either way
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value dependence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\begin_inset Foot
status open

\begin_layout Plain Layout
Agda and Coq aren't Turing complete.
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GADTs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\begin_inset Foot
status open

\begin_layout Plain Layout
Yes if we allow new Kinds
\begin_inset CommandInset citation
LatexCommand cite
key "gadtsext"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Generics
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Concept of equality
\end_layout

\begin_layout Standard
To be able to say if a type 
\family typewriter
T
\family default
 that depends on a value of 
\family typewriter
U
\family default
 (that is 
\family typewriter
T<U a>
\family default
) is equal to 
\family typewriter
T<U b>
\family default
 requires us to say what it means for 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 to be equal.
 All CLI objects have a method 
\family typewriter
bool Equal(object obj)
\family default
 which we could use, however this is clearly unsound as an implementation
 of 
\family typewriter
Equal
\family default
 could return nonsense, or never return at all.
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
I'm thinking this is done at compile time, not runtime (it's a static type
 check?)
\end_layout

\end_inset

Instead we propose using structural and reference equality.
 That is two values of any reference type are equal if and only if they
 are the same reference, and two values of a value type are equal if and
 only if all their fields are equal in this manner as well.
 In practice this amounts to checking that the values have the same bytes
 in memory.
\end_layout

\begin_layout Subsection
Immutability
\end_layout

\begin_layout Standard
Type preservation means that an expression's type should not change under
 evaluation, therfore value type parameters should be immutable.
 As shown in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Literal-and-initonly"

\end_inset

 the CLI does not have strong support for immutability.
 As such our initial work will concentrate on using the primitive types
 as their immutability can be easily guaranteed.
\end_layout

\begin_layout Subsection
Operations
\end_layout

\begin_layout Standard
Once we have the ability to mark up types with values, we will want to use
 the value for operations.
 Either for changing the value before passing it on as another type paramter
 or for using at runtime.
 Support for using the value in normal methods at runtime seems trivial,
 just expose it similar to a static readonly field.
 However supporting the ability to do operations on value parameters before
 passing them to another type constructor is more challenging.
 Firstly it will require some effort to fit into the CIL bytecode, currently
 opcodes are only allowed in method bodies, we would have to either point
 to a method to calculate the operations on value parameters or find some
 other way to fit opcodes at the declaration level.
 Secondly we have the issue of soundness as user defined operations can
 do anything.
\end_layout

\begin_layout Chapter
Project plan
\end_layout

\begin_layout Standard
As already briefly mentioned in the introduction this project can be split
 into three major parts, investigation, design and implementation.
\end_layout

\begin_layout Section
Investigation
\end_layout

\begin_layout Standard
The first part of the project is an investigation into value dependent types
 and similar systems.
 This has already been covered in our background research.
 From this we have an understanding of how these systems are useful and
 how they can be designed and implemented and this will guide us on the
 design of the CLI extension.
 This investigation forms the background research part of the final report
 and has mostly been done as part of this interim report.
\end_layout

\begin_layout Section
Design and implementation
\end_layout

\begin_layout Standard
The second part of the project is to design and implement extensions to
 the CLI.
 For each extension we will show what changes need to be made to ECMA-335
 to support the extension, and implement the extension in the open source
 CLI Mono.
 We list each of these and propose some detail of it's implementation, all
 syntax is highly subject to change however.
\end_layout

\begin_layout Enumerate
GADT extensions - 25
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 February
\end_layout

\begin_layout Enumerate
Primitive value parameters - 25
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 March
\end_layout

\begin_layout Enumerate
Value parameter constraints and operations - 22
\begin_inset script superscript

\begin_layout Plain Layout
nd
\end_layout

\end_inset

 April
\end_layout

\begin_layout Enumerate
User defined types as value parameters - 20
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 May
\end_layout

\begin_layout Enumerate
Further improvements and formalization - 17
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 June
\end_layout

\begin_layout Enumerate
Final report - 24
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 June
\end_layout

\begin_layout Subsection
GADTs
\end_layout

\begin_layout Standard
The first extension will be to add type equality constraints and a match
 and bind instruction to the CLI.
 To do this we will take the ideas from 
\begin_inset CommandInset citation
LatexCommand cite
key "gadts"

\end_inset

 and translate them to apply to the CLI.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "escapechar={~},keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Type equality constraints in extended C#
\begin_inset Newline newline
\end_inset

Extension of listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:csharp gadt"

\end_inset


\end_layout

\end_inset

public abstract class List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public abstract List<T> Append(List<T> list);
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() ~
\backslash
colorbox{yellow}{where T=List<U>;}~
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Nil<T> : List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public override List<T> Append(List<T> list)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return list;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public abstract List<U> Flatten<U>() // type constraints are inherited
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new Nil<U>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Cons<T> : List<T>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	T Head;
\end_layout

\begin_layout Plain Layout

	List<T> Tail;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Cons(T head, List<T> tail) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Head = head;
\end_layout

\begin_layout Plain Layout

		Tail = tail;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override List<T> Append(List<T> list)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new Cons<T>(Head, Tail.Append(list));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override List<U> Flatten<U>() // type constraints are inherited
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return Head.Append(Tail.Flatten<U>()); // invalid in standard C#
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "escapechar={~},tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Corresponding CIL
\end_layout

\end_inset

.class public abstract auto ansi beforefieldinit List<T>
\end_layout

\begin_layout Plain Layout

extends [mscorlib]System.Object 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	.method family hidebysig specialname rtspecialname instance void .ctor()
 
\end_layout

\begin_layout Plain Layout

		cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 8
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void [mscorlib]System.Object::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig newslot abstract virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{     }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig newslot abstract virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<~
\backslash
colorbox{yellow}{= T List<!!0>}~ U>() cil managed
\end_layout

\begin_layout Plain Layout

	{     }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.class public auto ansi beforefieldinit Nil<T>     
\end_layout

\begin_layout Plain Layout

	extends Test.List`1<!T> 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	.method public hidebysig specialname rtspecialname instance void .ctor()
 
\end_layout

\begin_layout Plain Layout

		cil managed     
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 8
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void Test.List`1<!T>::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 1
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<~
\backslash
colorbox{yellow}{= T List<!!0>}~ U>() cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 1
\end_layout

\begin_layout Plain Layout

		newobj instance void Test.Nil`1<!!U>::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.class public auto ansi beforefieldinit Cons<T>     
\end_layout

\begin_layout Plain Layout

extends Test.List`1<!T> 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	.method public hidebysig specialname rtspecialname instance void 
\end_layout

\begin_layout Plain Layout

		.ctor(!T head, class Test.List`1<!T> tail) cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 2        
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void Test.List`1<!T>::.ctor()
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		stfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldarg.2
\end_layout

\begin_layout Plain Layout

		stfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	.method public hidebysig virtual instance class 
\end_layout

\begin_layout Plain Layout

		Test.List`1<!T> Append(class Test.List`1<!T> list) cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 3
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		ldarg.1
\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!T>::Append(class Test.List`1<!0>)
\end_layout

\begin_layout Plain Layout

		newobj instance void Test.Cons`1<!T>::.ctor(!0, class Test.List`1<!0>)
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .method public hidebysig virtual instance class
\end_layout

\begin_layout Plain Layout

		Test.List`1<!!U> Flatten<~
\backslash
colorbox{yellow}{= T List<!!0>}~ U>() cil managed     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		.maxstack 2
\end_layout

\begin_layout Plain Layout

		nop
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld !0 Test.Cons`1<!T>::Head
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		ldfld class Test.List`1<!0> Test.Cons`1<!T>::Tail
\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!T>::Flatten<!!U>()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// the following callvirt would not verify in the standard CLI
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		callvirt instance class Test.List`1<!0> 
\end_layout

\begin_layout Plain Layout

			Test.List`1<!!U>::Append(class Test.List`1<!0>) 
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    .field private !T Head
\end_layout

\begin_layout Plain Layout

    .field private class Test.List`1<!T> Tail
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As per the style used in ECMA-335, match would be specified something like
 the following.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="75line%">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
match
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Format
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assembly Format
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\SpecialChar \ldots{}

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
match typetoken
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches and object against an open or closed generic type and returns the
 object cast to that type and the RuntimeHandles for the types required
 for closure if typetoken is an open generic type.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Stack Transition: \SpecialChar \ldots{}
, obj 
\begin_inset Formula $\rightarrow$
\end_inset

 \SpecialChar \ldots{}
, obj, RuntimeHandles
\end_layout

\begin_layout Subsection
Value parameters
\end_layout

\begin_layout Standard
The second extension is to add primitive value parameters to types and methods.
 This extension will only allow primitive types as parameters and has no
 support for constraints or operations on parameters at compile time.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Value parameters in extended C#
\end_layout

\end_inset

public class Value<int value>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static int Dup<int v>(Value<v> a, Value<v> b)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return Value<v>.value * 2;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public static void Print()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(value);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Corresponding CIL
\end_layout

\end_inset

.class public auto ansi beforefieldinit Value``1<int value>
\end_layout

\begin_layout Plain Layout

extends [mscorlib]System.Object 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	.method family hidebysig specialname rtspecialname instance void .ctor()
 
\end_layout

\begin_layout Plain Layout

		cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 8
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void [mscorlib]System.Object::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig static int32 
\end_layout

\begin_layout Plain Layout

		Dup``1<int v>(class Value``1<$$0> a, class Value``1<$$0> b) cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 2
\end_layout

\begin_layout Plain Layout

		.locals init (int32 temp)
\end_layout

\begin_layout Plain Layout

		ldsfld int32 Value``1<$$0>::value
\end_layout

\begin_layout Plain Layout

		ldc.i4.2 
\end_layout

\begin_layout Plain Layout

		mul
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig static void Print() cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ldsfld int32 Value``1<$0>::value
\end_layout

\begin_layout Plain Layout

		call void [mscorlib]System.Console::WriteLine(int32)
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Value constraints and operations
\end_layout

\begin_layout Standard
The third extension is to add constraints and operations to value parameters.
 It's unclear at this stage quite how this could work in CIL and so we don't
 provide an example of it.
\end_layout

\begin_layout Subsection
User defined types as value parameters
\end_layout

\begin_layout Standard
The final extension is to allow value parameters to be values of user defined
 types, not just primitive types.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "keywordstyle={\color{blue}},language=sharpc,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
User defined types as value parameters in extended C#
\end_layout

\end_inset

public class Value<MyClass c>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static int Access<MyStruct s>()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return s.field;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public static void Print()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(c.property);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Corresponding CIL
\end_layout

\end_inset

.class public auto ansi beforefieldinit Value``1<class MyClass c>
\end_layout

\begin_layout Plain Layout

extends [mscorlib]System.Object 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	.method family hidebysig specialname rtspecialname instance void .ctor()
 
\end_layout

\begin_layout Plain Layout

		cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 8
\end_layout

\begin_layout Plain Layout

		ldarg.0
\end_layout

\begin_layout Plain Layout

		call instance void [mscorlib]System.Object::.ctor()
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig static int32 
\end_layout

\begin_layout Plain Layout

		Access``1<MyStruct s>() cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		.maxstack 2
\end_layout

\begin_layout Plain Layout

		ldvalue $$0
\end_layout

\begin_layout Plain Layout

		ldfld int32 MyStruct::field
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.method public hidebysig static void Print() cil managed
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ldvalue $0
\end_layout

\begin_layout Plain Layout

		callvirt instance int32 MyClass::get_property()    
\end_layout

\begin_layout Plain Layout

		call void [mscorlib]System.Console::WriteLine(int32)
\end_layout

\begin_layout Plain Layout

		ret
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Evaluation plan
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
Defining semantics for what value dependence means can be done in two ways.
 Firstly we could extend the ECMA specification (
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-335"

\end_inset

).
 Secondly we could take a formal specification of the CLI and extend that.
 While work has been done on formalization of CLI languages such as C#,
 work on formalizing the CLI does not seem to have been done.
 If we can work out how value dependence should work in the CLI then extending
 the ECMA specification is a required aim, as it is the basis for compiler
 writers targeting the CLI.
 Extending a formal specification would be a stretch goal to complete once
 other goals are achieved, both because it may require translating our extension
 to C# to use a lightweight C# formalization based on featherweight GJ and
 secondly as a formalization is not required for the implementation work.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
Given an extension to the CLI specification we want to show that the extension
 can be implemented.
 To do this we will extend the open source Mono run time to support value
 dependent types.
 The most important aspect is correctness but performance should be kept
 in mind.
 As pointed out in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Performance"

\end_inset

 we want certain performance characteristics out of the system.
 For each extension we will include test cases to demonstrate that the implement
ation is correct.
 Test cases will be created both during the development of each extension
 and, time permiting, some time after the extension is finished.
\end_layout

\begin_layout Chapter
References
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "report"
options "plain"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Still need to fix this.
 Also need to setup a glossary.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
